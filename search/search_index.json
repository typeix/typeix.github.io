{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"benchmarks/","text":"Benchmarks \u00b6 I'm personally not fun of micro benchmarks because applications can be optimized on multiple layers, however you can find results below. Machine: Rayzen 7 3800x 8c/16t | docker linux x64 | 2 vCPU | 4GB RAM Node: node:14 Method: autocannon -c 100 -d 40 -p 10 localhost:3000 (two rounds; one to warm-up, one to measure) Version Router Requests/s Latency Throughput/Mb fastify ^3.0.0 \u2713 81185.61 11.82 15.18 @nestjs/platform-fastify ^7.6.15 \u2713 68189.2 14.17 12.75 @typeix/router ^7.4.1 \u2713 65384.4 14.8 9.15 @typeix/resty ^7.4.1 \u2713 55476.8 17.53 7.77 express ^4.16.4 \u2713 17665.6 56.1 3.30 @nestjs/platform-express ^7.6.15 \u2713 14079 70.47 3.55 code you can find on benchmarks repository","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"I'm personally not fun of micro benchmarks because applications can be optimized on multiple layers, however you can find results below. Machine: Rayzen 7 3800x 8c/16t | docker linux x64 | 2 vCPU | 4GB RAM Node: node:14 Method: autocannon -c 100 -d 40 -p 10 localhost:3000 (two rounds; one to warm-up, one to measure) Version Router Requests/s Latency Throughput/Mb fastify ^3.0.0 \u2713 81185.61 11.82 15.18 @nestjs/platform-fastify ^7.6.15 \u2713 68189.2 14.17 12.75 @typeix/router ^7.4.1 \u2713 65384.4 14.8 9.15 @typeix/resty ^7.4.1 \u2713 55476.8 17.53 7.77 express ^4.16.4 \u2713 17665.6 56.1 3.30 @nestjs/platform-express ^7.6.15 \u2713 14079 70.47 3.55 code you can find on benchmarks repository","title":"Benchmarks"},{"location":"packages/","text":"Introduction \u00b6 Typeix is Fast, unopinionated, minimalist framework for building efficient and scalable applications and libraries. In 2016 inspired by Angular first version of typeix was born, which provides an application architecture to allow effortless creation of highly testable, scalable, loosely coupled and easily maintainable applications. Packages \u00b6 Package Comment @typeix/utils Helper library used by @typeix packages internally but nobody stops you from using it :fontawesome-solid-smile: @typeix/metadata High level metadata processor api, you can create own decorators of all types, library takes care that all values are properly stored & inherited @typeix/di Extensive Dependency Injector library inspired by Angular which supports custom extensions and method interceptors @typeix/modules Module definition library which comes with ModuleInjector and allows you to create modules take care of imports, exports & module providers out of the box @typeix/router Low level server and routing api, which supports http, https, http2 servers and comes with dynamic routing options & custom error handlers on any route @typeix/logger Wrapper around pino logger library @typeix/resty High level REST server implementation @typeix/resty-aws-lambda One line AWS Lambda integration with resty server","title":"Packages Introduction"},{"location":"packages/#introduction","text":"Typeix is Fast, unopinionated, minimalist framework for building efficient and scalable applications and libraries. In 2016 inspired by Angular first version of typeix was born, which provides an application architecture to allow effortless creation of highly testable, scalable, loosely coupled and easily maintainable applications.","title":"Introduction"},{"location":"packages/#packages","text":"Package Comment @typeix/utils Helper library used by @typeix packages internally but nobody stops you from using it :fontawesome-solid-smile: @typeix/metadata High level metadata processor api, you can create own decorators of all types, library takes care that all values are properly stored & inherited @typeix/di Extensive Dependency Injector library inspired by Angular which supports custom extensions and method interceptors @typeix/modules Module definition library which comes with ModuleInjector and allows you to create modules take care of imports, exports & module providers out of the box @typeix/router Low level server and routing api, which supports http, https, http2 servers and comes with dynamic routing options & custom error handlers on any route @typeix/logger Wrapper around pino logger library @typeix/resty High level REST server implementation @typeix/resty-aws-lambda One line AWS Lambda integration with resty server","title":"Packages"},{"location":"roadmap/","text":"Roadmap \u00b6 In 2016 first Typeix version was born, however I never created proper documentation or advertise framework & tools. I'm currently working in my spare time to deliver new features, proper documentation, free video courses. Features \u00b6 7.5.0 CLI Tools 8.x TypeORM (Documentation only, it's fully compatible with TypeORM) 8.x Mongo (Documentation only, it's fully compatible with Mongoose for Typescript) 8.x Redis (Documentation only, it's fully compatible with Redis for Typescript) 8.x Kafka (Documentation only, it's fully compatible with Kafka for Typescript) 8.x KeyCloak, JWT (Documentation only, it's fully compatible with Keycloack.js for Typescript) 8.x GraphQL Adapter - (Documentation only, it's fully compatible with type-graphql for Typescript) 8.x Configuration Management - (Documentation only) 8.4.0 Websockets Integration 8.5.0 Swagger Support You can request feature via twitter or github, which can be voted and will be added as separate package.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"In 2016 first Typeix version was born, however I never created proper documentation or advertise framework & tools. I'm currently working in my spare time to deliver new features, proper documentation, free video courses.","title":"Roadmap"},{"location":"roadmap/#features","text":"7.5.0 CLI Tools 8.x TypeORM (Documentation only, it's fully compatible with TypeORM) 8.x Mongo (Documentation only, it's fully compatible with Mongoose for Typescript) 8.x Redis (Documentation only, it's fully compatible with Redis for Typescript) 8.x Kafka (Documentation only, it's fully compatible with Kafka for Typescript) 8.x KeyCloak, JWT (Documentation only, it's fully compatible with Keycloack.js for Typescript) 8.x GraphQL Adapter - (Documentation only, it's fully compatible with type-graphql for Typescript) 8.x Configuration Management - (Documentation only) 8.4.0 Websockets Integration 8.5.0 Swagger Support You can request feature via twitter or github, which can be voted and will be added as separate package.","title":"Features"},{"location":"documentation/getting-started/","text":"Getting started \u00b6 Prerequisites \u00b6 Please make sure that Node.js (gte >= 18.x) is installed on your operating system. Description \u00b6 Typeix supports both typescript and javascript development with babel compiler! Typescript \u00b6 $ npm i -g @typeix/cli $ typeix new project-name $ cd project-name $ typeix start --watch The project directory will be created, node modules and a few other boilerplate files will be installed, and a src/ directory will be created and populated with several core files. src L app.controller.spec.ts L app.controller.ts L app.module.ts L app.service.ts L bootstrap.ts File Description app.controller.spec.ts The unit tests for the controller. app.controller.ts A basic controller with a single route. app.module.ts The root module of the application. app.service.ts A basic service with a single method. bootstrap.ts Application Server Config File Javascript \u00b6 Babel 7.0.0 introduced a decorators @babel/plugin-proposal-decorators plugin for javascript! Typeix is fully compatible to develop application in javascript with babel compiler! $ typeix new project-name -l js $ cd project-name $ npm run start:dev The project directory will be created, and in src you can find boilerplate javascript files! src L app.controller.spec.js L app.controller.js L app.module.js L app.service.js L bootstrap.js All decorators which are possible to use in typescript you can use them the same way in javascript! All Typeix packages are compatible with javascript development: Resty, Dependency Injection, Metadata, Router, Logger and Resty Lambda! File Description app.controller.spec.js The unit tests for the controller. app.controller.js A basic controller with a single route. app.module.js The root module of the application. app.service.js A basic service with a single method. bootstrap.js Application Server Config File","title":"Getting Started"},{"location":"documentation/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"documentation/getting-started/#prerequisites","text":"Please make sure that Node.js (gte >= 18.x) is installed on your operating system.","title":"Prerequisites"},{"location":"documentation/getting-started/#description","text":"Typeix supports both typescript and javascript development with babel compiler!","title":"Description"},{"location":"documentation/getting-started/#typescript","text":"$ npm i -g @typeix/cli $ typeix new project-name $ cd project-name $ typeix start --watch The project directory will be created, node modules and a few other boilerplate files will be installed, and a src/ directory will be created and populated with several core files. src L app.controller.spec.ts L app.controller.ts L app.module.ts L app.service.ts L bootstrap.ts File Description app.controller.spec.ts The unit tests for the controller. app.controller.ts A basic controller with a single route. app.module.ts The root module of the application. app.service.ts A basic service with a single method. bootstrap.ts Application Server Config File","title":"Typescript"},{"location":"documentation/getting-started/#javascript","text":"Babel 7.0.0 introduced a decorators @babel/plugin-proposal-decorators plugin for javascript! Typeix is fully compatible to develop application in javascript with babel compiler! $ typeix new project-name -l js $ cd project-name $ npm run start:dev The project directory will be created, and in src you can find boilerplate javascript files! src L app.controller.spec.js L app.controller.js L app.module.js L app.service.js L bootstrap.js All decorators which are possible to use in typescript you can use them the same way in javascript! All Typeix packages are compatible with javascript development: Resty, Dependency Injection, Metadata, Router, Logger and Resty Lambda! File Description app.controller.spec.js The unit tests for the controller. app.controller.js A basic controller with a single route. app.module.js The root module of the application. app.service.js A basic service with a single method. bootstrap.js Application Server Config File","title":"Javascript"},{"location":"documentation/fundamentals/di/","text":"Dependency Injection \u00b6 Dependency Injection (DI) is a design pattern used in software development to promote loose coupling and improve the maintainability, testability, and scalability of applications. It's a technique where a component's dependencies (i.e., the objects or services it relies on) are provided to it from an external source, rather than being created within the component itself. Here are key concepts of Dependency Injection: Inversion of Control (IoC): DI is a specific implementation of the more general IoC principle. In IoC, the control over the instantiation and management of dependencies is inverted or \"inverted\" from the component itself to an external entity (often a container or framework). Components and Dependencies: In a software system, components are pieces of code or classes that perform specific functions. Dependencies are the objects, services, or resources that a component needs to accomplish its tasks. Dependency Injection Container (DIC): A DIC is a framework or container that manages the instantiation and wiring of components and their dependencies. It simplifies the process of configuring and injecting dependencies, reducing the manual effort required. Benefits of DI: Testability: DI makes it easier to write unit tests for components because dependencies can be replaced with mock or stub objects for testing purposes. Flexibility: It allows for easy swapping of implementations or configurations without modifying the component's code. Maintainability: DI promotes cleaner, more modular code by explicitly defining dependencies and their relationships. Reduced Coupling: Components are not tightly bound to specific implementations of their dependencies, making it easier to change or extend functionality. Drawbacks of DI: Learning Curve: Implementing DI may require developers to understand and adopt new patterns and practices. Potential Complexity: In large applications, managing a large number of dependencies and their configurations can become complex without the use of a DI container. In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern. Decorator use can be more efficient than subclassing, because an object's behavior can be augmented without defining an entirely new object. Implementation \u00b6 In order to create an object of some class you need to decorate class with @Injectable and injection points via @Inject , then when creating an instance you need to provide DI what to construct and which providers to create. import { Injectable , Injector , Inject } from \"@typeix/di\" ; @Injectable () class NameService { @Inject ( \"name\" ) private name : string ; getName () { return this . name ; } } @Injectable () class ChildService { @Inject () nameService : NameService ; getName () : string { return this . nameService . getName (); } } Injector . createAndResolve ( ChildService , [ { provide : \"name\" , useValue : \"Igor\" }, NameService ]). then ( injector => { let service = injector . get ( ChildService ); return service . getName (); }); Decorators \u00b6 Decorator Info @Injectable() specifies that Typeix can use this class in the DI system. decorators can be used on classes only. @Inject() specifies DI system, which object to provide when object is created, if there is no provider defined DI will throw error with explanation. @AfterConstruct() specifies DI system, what to execute immediately after object is created. @CreateProvider() decorator specifies DI system, to create new provider on injection point, this will create new object even if there is a provider defined in parent Injector. Provider Types \u00b6 There are three type of providers class, value and factory provider, functions inside providers array are converted to class providers. There are three types of providers in total: {provde, useClass} is a class provider. {provde, useFactory} is a factory provider. {provde, useValue} is a value provider. Dependent providers?: Array<Function | IProvider> inside of provider (class and factory) are extra dependencies that are created before provider and delivered as dependencies to provider itself. interface IProvider { provide : any ; useValue? : any ; useClass? : Function ; useFactory? : Function ; providers? : Array < Function | IProvider > ; } Interceptors \u00b6 An interceptor pattern is a software design pattern that is used when software systems or frameworks want to offer a way to change, or augment, their usual processing cycle. import { Injectable , Injector , Inject , createMethodInterceptor } from \"@typeix/di\" ; @Injectable () class LoggerInterceptor implements Interceptor { @Inject () logger : Logger ; async invoke ( method : Method ) : Promise < any > { const result = await method . invoke (); this . logger . info ( method . args . message , result ); return result ; } } export function Logger ( message ) { return createMethodInterceptor ( Logger , LoggerInterceptor , { message }); }; @Injectable () class ChildService { @Logger ( \"Logging ChildService.getName result: \" ) getName () : string { return this . name ; } }","title":"Dependency Injection"},{"location":"documentation/fundamentals/di/#dependency-injection","text":"Dependency Injection (DI) is a design pattern used in software development to promote loose coupling and improve the maintainability, testability, and scalability of applications. It's a technique where a component's dependencies (i.e., the objects or services it relies on) are provided to it from an external source, rather than being created within the component itself. Here are key concepts of Dependency Injection: Inversion of Control (IoC): DI is a specific implementation of the more general IoC principle. In IoC, the control over the instantiation and management of dependencies is inverted or \"inverted\" from the component itself to an external entity (often a container or framework). Components and Dependencies: In a software system, components are pieces of code or classes that perform specific functions. Dependencies are the objects, services, or resources that a component needs to accomplish its tasks. Dependency Injection Container (DIC): A DIC is a framework or container that manages the instantiation and wiring of components and their dependencies. It simplifies the process of configuring and injecting dependencies, reducing the manual effort required. Benefits of DI: Testability: DI makes it easier to write unit tests for components because dependencies can be replaced with mock or stub objects for testing purposes. Flexibility: It allows for easy swapping of implementations or configurations without modifying the component's code. Maintainability: DI promotes cleaner, more modular code by explicitly defining dependencies and their relationships. Reduced Coupling: Components are not tightly bound to specific implementations of their dependencies, making it easier to change or extend functionality. Drawbacks of DI: Learning Curve: Implementing DI may require developers to understand and adopt new patterns and practices. Potential Complexity: In large applications, managing a large number of dependencies and their configurations can become complex without the use of a DI container. In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern. Decorator use can be more efficient than subclassing, because an object's behavior can be augmented without defining an entirely new object.","title":"Dependency Injection"},{"location":"documentation/fundamentals/di/#implementation","text":"In order to create an object of some class you need to decorate class with @Injectable and injection points via @Inject , then when creating an instance you need to provide DI what to construct and which providers to create. import { Injectable , Injector , Inject } from \"@typeix/di\" ; @Injectable () class NameService { @Inject ( \"name\" ) private name : string ; getName () { return this . name ; } } @Injectable () class ChildService { @Inject () nameService : NameService ; getName () : string { return this . nameService . getName (); } } Injector . createAndResolve ( ChildService , [ { provide : \"name\" , useValue : \"Igor\" }, NameService ]). then ( injector => { let service = injector . get ( ChildService ); return service . getName (); });","title":"Implementation"},{"location":"documentation/fundamentals/di/#decorators","text":"Decorator Info @Injectable() specifies that Typeix can use this class in the DI system. decorators can be used on classes only. @Inject() specifies DI system, which object to provide when object is created, if there is no provider defined DI will throw error with explanation. @AfterConstruct() specifies DI system, what to execute immediately after object is created. @CreateProvider() decorator specifies DI system, to create new provider on injection point, this will create new object even if there is a provider defined in parent Injector.","title":"Decorators"},{"location":"documentation/fundamentals/di/#provider-types","text":"There are three type of providers class, value and factory provider, functions inside providers array are converted to class providers. There are three types of providers in total: {provde, useClass} is a class provider. {provde, useFactory} is a factory provider. {provde, useValue} is a value provider. Dependent providers?: Array<Function | IProvider> inside of provider (class and factory) are extra dependencies that are created before provider and delivered as dependencies to provider itself. interface IProvider { provide : any ; useValue? : any ; useClass? : Function ; useFactory? : Function ; providers? : Array < Function | IProvider > ; }","title":"Provider Types"},{"location":"documentation/fundamentals/di/#interceptors","text":"An interceptor pattern is a software design pattern that is used when software systems or frameworks want to offer a way to change, or augment, their usual processing cycle. import { Injectable , Injector , Inject , createMethodInterceptor } from \"@typeix/di\" ; @Injectable () class LoggerInterceptor implements Interceptor { @Inject () logger : Logger ; async invoke ( method : Method ) : Promise < any > { const result = await method . invoke (); this . logger . info ( method . args . message , result ); return result ; } } export function Logger ( message ) { return createMethodInterceptor ( Logger , LoggerInterceptor , { message }); }; @Injectable () class ChildService { @Logger ( \"Logging ChildService.getName result: \" ) getName () : string { return this . name ; } }","title":"Interceptors"},{"location":"documentation/fundamentals/model-view-controller/","text":"Model View Controller \u00b6 The Model-View-Controller (MVC) is a widely used software architecture pattern that separates the concerns of an application into three main components: the Model, the View, and the Controller. This pattern aims to enhance the maintainability, scalability, and flexibility of software systems. Model (M): The Model represents the data and business logic of the application. It encapsulates the data structures, database interactions, and algorithms that handle the application's core functionality. The Model is independent of the user interface and can be modified without affecting the other components. View (V): The View is responsible for presenting the user interface to the end-users. It renders the data from the Model and displays it in a format that is understandable and accessible to the user. Views can include graphical user interfaces, command-line interfaces, web pages, or any other presentation medium. Controller (C): The Controller acts as an intermediary between the Model and the View. It receives input from the user (e.g., through a GUI or a web page), processes it, and triggers the necessary actions in the Model. The Controller also updates the View to reflect any changes in the Model's state. By separating the application into these three components, the MVC pattern promotes modularity, making it easier to develop, test, and maintain software systems. Additionally, it allows for parallel development, as different teams can work on different components independently. This pattern is widely used in various software development frameworks and is a fundamental concept in building robust and scalable applications. In order to create an MVC app, we also need a template engine to render our HTML views. Typeix resty support any templating engine, for this example we are going to use handlebars. Installation \u00b6 Let's start by installing typeix cli and creating new project! npm i -g @typeix/cli Let's create new project: typeix new app-mvc cd app-mvc Let's install handlebars: npm i --save handlebars npm i --save-dev @types/handlebars Goal is to create following structure: src L services L template.service.ts L interceptors L render.interceptor.ts L app.controller.ts L app.service.ts L app.module.ts L bootstrap.ts views L main.hbs Templates \u00b6 All templates we should keep outside source files, inside views folder: mkdir views Let's create custom template main.hbs: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\" /> <link rel=\"stylesheet\" href=\"/assets/css/main.css\" /> <meta charset=\"UTF-8\"> <title> {{ title }} </title> </head> <body> <img src=\"/assets/logo.png\" width=\"100\"/> <h1>Headline: {{ name }} </h1> <p> Methods id: {{ id }} name: {{ name }} ; </p> </body> </html> Service \u00b6 Let's create a template service which is responsible for loading, compiling and rendering template from disk. NOTE: In following example we are going to load and compile template and store it in memory for production use it's better to precompile template and loading it from disk as javascript file. import { normalize } from \"path\" ; import { readFile } from \"fs\" ; import { Injectable } from \"@typeix/resty\" ; import { compile } from \"handlebars\" ; @Injectable () export class TemplateEngineService { templates : Map < string , HandlebarsTemplateDelegate > = new Map (); /** * Gets template path * @return {String} */ static getTemplatePath ( name : String ) : string { return normalize ( process . cwd () + \"/views/\" + name + \".hbs\" ); } /** * Read file from disk * @param template */ async readFile ( template : String ) : Promise < HandlebarsTemplateDelegate > { const path = TemplateEngineService . getTemplatePath ( template ); if ( this . templates . has ( path )) { return Promise . resolve ( this . templates . get ( path )); } return new Promise (( resolve , reject ) => { readFile ( path , { encoding : \"utf8\" }, ( err , data ) => { if ( err ) { reject ( err ); } else { const tpl = compile ( data ); this . templates . set ( path , tpl ); resolve ( tpl ); } } ); }); } /** * Load template from disk * @param template * @param data * @returns {NodeJS.ReadableStream} */ async compileAndRender ( template : String , data : any ) : Promise < Buffer > { const tpl = await this . readFile ( template ); const html = tpl ( data ); return Buffer . from ( html ); } } Controller \u00b6 In controllers, we need to use template engine service to compile and render template with custom data. import { Inject , Controller , GET , PathParam , ResolvedRoute , IResolvedRoute } from \"@typeix/resty\" ; import { TemplateEngineService } from \"~/services/templating-engine.service\" ; import { Render } from \"~/interceptors/render.interceptor\" ; @Controller ({ path : \"/\" }) export class HomeController { @Inject () engine : TemplateEngineService ; @GET () async actionIndex () : Promise < Buffer > { return await this . engine . compileAndRender ( \"main\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); } } NOTE: In following example we did not use models, we just send data from controller as mock. Render Interceptor \u00b6 In order to make repeatable TemplateEngineService code obsolete, we will move that code into method interceptor. import { createMethodInterceptor , Inject , Injectable , Interceptor , Method } from \"@typeix/resty\" ; import { TemplateEngineService } from \"~/components/templating-engine.service\" ; @Injectable () export class RenderInterceptor implements Interceptor { @Inject () engine : TemplateEngineService ; async invoke ( method : Method ) : Promise < any > { const data = await method . invoke (); const result = await this . engine . compileAndRender ( method . decoratorArgs . value , data ); return await method . transform ( result ); } } /** * Asset loader service * @constructor * @function * @name Render * * @description * RenderInterceptor template */ export function Render ( value : string ) { return createMethodInterceptor ( Render , RenderInterceptor , { value }); } In following example you can see that Injecting TemplateEngineService is no longer required because we created custom decorator, and we decorated our controller action. import { Inject , Controller , GET , PathParam , ResolvedRoute , IResolvedRoute } from \"@typeix/resty\" ; import { Render } from \"~/interceptors/render.interceptor\" ; @Controller ({ path : \"/\" }) export class HomeController { @GET () @Render ( \"main\" ) async actionIndex () : Promise < Buffer > { return { id , name , title : \"Template engine with typeix\" }; } }","title":"Model View Controller"},{"location":"documentation/fundamentals/model-view-controller/#model-view-controller","text":"The Model-View-Controller (MVC) is a widely used software architecture pattern that separates the concerns of an application into three main components: the Model, the View, and the Controller. This pattern aims to enhance the maintainability, scalability, and flexibility of software systems. Model (M): The Model represents the data and business logic of the application. It encapsulates the data structures, database interactions, and algorithms that handle the application's core functionality. The Model is independent of the user interface and can be modified without affecting the other components. View (V): The View is responsible for presenting the user interface to the end-users. It renders the data from the Model and displays it in a format that is understandable and accessible to the user. Views can include graphical user interfaces, command-line interfaces, web pages, or any other presentation medium. Controller (C): The Controller acts as an intermediary between the Model and the View. It receives input from the user (e.g., through a GUI or a web page), processes it, and triggers the necessary actions in the Model. The Controller also updates the View to reflect any changes in the Model's state. By separating the application into these three components, the MVC pattern promotes modularity, making it easier to develop, test, and maintain software systems. Additionally, it allows for parallel development, as different teams can work on different components independently. This pattern is widely used in various software development frameworks and is a fundamental concept in building robust and scalable applications. In order to create an MVC app, we also need a template engine to render our HTML views. Typeix resty support any templating engine, for this example we are going to use handlebars.","title":"Model View Controller"},{"location":"documentation/fundamentals/model-view-controller/#installation","text":"Let's start by installing typeix cli and creating new project! npm i -g @typeix/cli Let's create new project: typeix new app-mvc cd app-mvc Let's install handlebars: npm i --save handlebars npm i --save-dev @types/handlebars Goal is to create following structure: src L services L template.service.ts L interceptors L render.interceptor.ts L app.controller.ts L app.service.ts L app.module.ts L bootstrap.ts views L main.hbs","title":"Installation"},{"location":"documentation/fundamentals/model-view-controller/#templates","text":"All templates we should keep outside source files, inside views folder: mkdir views Let's create custom template main.hbs: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\" /> <link rel=\"stylesheet\" href=\"/assets/css/main.css\" /> <meta charset=\"UTF-8\"> <title> {{ title }} </title> </head> <body> <img src=\"/assets/logo.png\" width=\"100\"/> <h1>Headline: {{ name }} </h1> <p> Methods id: {{ id }} name: {{ name }} ; </p> </body> </html>","title":"Templates"},{"location":"documentation/fundamentals/model-view-controller/#service","text":"Let's create a template service which is responsible for loading, compiling and rendering template from disk. NOTE: In following example we are going to load and compile template and store it in memory for production use it's better to precompile template and loading it from disk as javascript file. import { normalize } from \"path\" ; import { readFile } from \"fs\" ; import { Injectable } from \"@typeix/resty\" ; import { compile } from \"handlebars\" ; @Injectable () export class TemplateEngineService { templates : Map < string , HandlebarsTemplateDelegate > = new Map (); /** * Gets template path * @return {String} */ static getTemplatePath ( name : String ) : string { return normalize ( process . cwd () + \"/views/\" + name + \".hbs\" ); } /** * Read file from disk * @param template */ async readFile ( template : String ) : Promise < HandlebarsTemplateDelegate > { const path = TemplateEngineService . getTemplatePath ( template ); if ( this . templates . has ( path )) { return Promise . resolve ( this . templates . get ( path )); } return new Promise (( resolve , reject ) => { readFile ( path , { encoding : \"utf8\" }, ( err , data ) => { if ( err ) { reject ( err ); } else { const tpl = compile ( data ); this . templates . set ( path , tpl ); resolve ( tpl ); } } ); }); } /** * Load template from disk * @param template * @param data * @returns {NodeJS.ReadableStream} */ async compileAndRender ( template : String , data : any ) : Promise < Buffer > { const tpl = await this . readFile ( template ); const html = tpl ( data ); return Buffer . from ( html ); } }","title":"Service"},{"location":"documentation/fundamentals/model-view-controller/#controller","text":"In controllers, we need to use template engine service to compile and render template with custom data. import { Inject , Controller , GET , PathParam , ResolvedRoute , IResolvedRoute } from \"@typeix/resty\" ; import { TemplateEngineService } from \"~/services/templating-engine.service\" ; import { Render } from \"~/interceptors/render.interceptor\" ; @Controller ({ path : \"/\" }) export class HomeController { @Inject () engine : TemplateEngineService ; @GET () async actionIndex () : Promise < Buffer > { return await this . engine . compileAndRender ( \"main\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); } } NOTE: In following example we did not use models, we just send data from controller as mock.","title":"Controller"},{"location":"documentation/fundamentals/model-view-controller/#render-interceptor","text":"In order to make repeatable TemplateEngineService code obsolete, we will move that code into method interceptor. import { createMethodInterceptor , Inject , Injectable , Interceptor , Method } from \"@typeix/resty\" ; import { TemplateEngineService } from \"~/components/templating-engine.service\" ; @Injectable () export class RenderInterceptor implements Interceptor { @Inject () engine : TemplateEngineService ; async invoke ( method : Method ) : Promise < any > { const data = await method . invoke (); const result = await this . engine . compileAndRender ( method . decoratorArgs . value , data ); return await method . transform ( result ); } } /** * Asset loader service * @constructor * @function * @name Render * * @description * RenderInterceptor template */ export function Render ( value : string ) { return createMethodInterceptor ( Render , RenderInterceptor , { value }); } In following example you can see that Injecting TemplateEngineService is no longer required because we created custom decorator, and we decorated our controller action. import { Inject , Controller , GET , PathParam , ResolvedRoute , IResolvedRoute } from \"@typeix/resty\" ; import { Render } from \"~/interceptors/render.interceptor\" ; @Controller ({ path : \"/\" }) export class HomeController { @GET () @Render ( \"main\" ) async actionIndex () : Promise < Buffer > { return { id , name , title : \"Template engine with typeix\" }; } }","title":"Render Interceptor"},{"location":"documentation/graphql/directives/","text":"","title":"GraphQL - Directives"},{"location":"documentation/graphql/mutations/","text":"","title":"GraphQL - Mutations"},{"location":"documentation/graphql/quick-start/","text":"GraphQL \u00b6 Is a query language and runtime for APIs (Application Programming Interfaces) that provides a more flexible and efficient way to interact with web services compared to traditional RESTful APIs. Key characteristics of GraphQL include: Efficient Data Retrieval : With GraphQL, clients can request only the specific data they need, reducing over-fetching or under-fetching of information. This contrasts with traditional RESTful APIs, where endpoints often return fixed data structures. Single Endpoint : Unlike REST, which may require multiple endpoints for different resources, GraphQL typically exposes a single endpoint for all interactions. This simplifies API management and reduces the need for versioning. Strongly Typed Schema : GraphQL uses a schema to define the types of data available and the relationships between them. This schema serves as a contract between the client and server, ensuring that only valid queries are accepted. Nested Queries : Clients can request related data in a single query, allowing for deeply nested requests. This minimizes the need for multiple round-trips to the server. Real-time Updates : GraphQL can support real-time updates through subscriptions, enabling applications to receive instant notifications about changes in data. Introspection : Clients can query the schema itself, allowing for dynamic discovery of available types, queries, and mutations. This introspection capability is valuable for tooling and development. Versionless API : Since GraphQL clients can request exactly the data they need, there is less need for versioning of APIs. This can lead to more flexible and maintainable APIs. GraphQL is particularly well-suited for modern web and mobile applications, where data requirements can be dynamic and diverse. It has gained popularity in recent years and is supported by a vibrant community, along with tooling and libraries for various programming languages. While GraphQL offers significant benefits, it may not be the best choice for all scenarios, and the decision to use it should be based on the specific requirements and constraints of a given project. Quick Start \u00b6 GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL combined with TypeScript helps you develop better type safety with your GraphQL queries, giving you end-to-end typing. See Comparison between GraphQL and REST. In this chapter, we assume a basic understanding of GraphQL, and focus on how to work with the Type-GraphQL module. Installation \u00b6 Start by installing the required packages: $ npm i -g @typeix/cli $ typeix new grapql-project $ cd grapql-project $ npm i type-graphql graphql class-validator $ typeix start --watch Type-GraphQL offers two ways of building GraphQL applications, the code first and the schema first methods. You should choose the one that works best for you. Most of the chapters in this GraphQL section are divided into two main parts: one you should follow if you adopt code first, and the other to be used if you adopt schema first. Resty fully supports integration with type-graphql without any extra library or adapter. You can find full example in resty starters repository . Resty with Graphql \u00b6 Goal is to generate following structure: src L controllers L rest L test L user.controller.integration-spec.ts L permission.controller.integration-spec.ts L permission.controller.ts L user.controller.ts L graphql L test L permission.resolver.integration-spec.ts L user.resolver.integration-spec.ts L graphql.config.ts L graphql.controller.ts L user.resolver.ts L permission.resolver.ts L services L user.service.ts L permission.service.ts L app.module.ts L bootstrap.ts Schema config \u00b6 In following example graphql.config.ts we need to use type-graphql to build schema, schema can be generated from code or from schema .gql file using graphql syntax, in schema config we need to declare all resolvers. import { CreateProvider , Injectable , RouterError } from \"@typeix/resty\" ; import { buildSchema } from \"type-graphql\" ; import { GraphQLSchema } from \"graphql\" ; import { UserResolver } from \"~/controllers/graphql/user.resolver\" ; import { PermissionResolver } from \"~/controllers/graphql/permission.resolver\" ; @Injectable () export class GraphQLConfig { @CreateProvider ({ provide : \"GraphqlConfigSchema\" , useFactory : async () => { return await buildSchema ({ resolvers : [ UserResolver , PermissionResolver ], container : ({ context }) => context . container }); }, providers : [] }) private schema : GraphQLSchema ; public getSchema () : GraphQLSchema { return this . schema ; } public parseBody ( body : Buffer ) : any { try { return JSON . parse ( body . toString ()); } catch ( e ) { throw new RouterError ( \"GraphQL syntax error, cannot parse json request\" , 400 ); } } } Controller \u00b6 In order for GraphQL to process request it needs to have only one REST endpoint which accepts request body as json which contains query operation name and variables, query can contain graphql query and mutations. It's important to provide all resolvers to graphql controller injection point, because that would create new instance of resolvers on each request. import { addRequestInterceptor , BodyAsBufferInterceptor , Controller , Inject , Injector , POST , RouterError } from \"@typeix/resty\" ; import { PermissionResolver } from \"~/controllers/graphql/permission.resolver\" ; import { UserResolver } from \"~/controllers/graphql/user.resolver\" ; import { GraphQLConfig } from \"~/controllers/graphql/graphql.config\" ; import { graphql , parse , Source , specifiedRules , validate } from \"graphql\" ; @Controller ({ path : \"/graphql\" , providers : [ PermissionResolver , UserResolver ], interceptors : [] }) export class GraphQLController { @Inject () graphQlConfig : GraphQLConfig ; @Inject () injector : Injector ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) processGraphQL ( @Inject () body : Buffer ) { let schema = this . graphQlConfig . getSchema (); let { query , operationName , variables } = this . graphQlConfig . parseBody ( body ); let source = new Source ( query , operationName ); let documentAST = parse ( source ); let validationErrors = validate ( schema , documentAST , specifiedRules ); if ( validationErrors . length > 0 ) { throw new RouterError ( \"GraphQL validation error.\" , 400 , validationErrors ); } return graphql ( schema , source , null , { container : this.injector }, variables , operationName ); } } Resolvers \u00b6 Resolvers are like REST controllers, but it's based on graphql api and there you should define your queries and mutations. You can specify type of resolver or you can live out type on resolver and bind it to query or mutation. import { Inject , Injectable } from \"@typeix/resty\" ; import { Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) users () : Array < User > { return this . userService . find (); } } In following example we can see definition of user scalar type: @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field () age : number ; static new ( id : number , firstName : string , lastName : string , age : number ) : User { let obj = new User (); obj . id = id ; obj . firstName = firstName ; obj . lastName = lastName ; obj . age = age ; return obj ; } } User service data mock, normally we would call database to fetch data in service: import { Injectable } from \"@typeix/resty\" ; import { User } from \"~/data/user.entity\" ; @Injectable () export class UserService { find () : Array < User > { return [ User . new ( 1 , \"John\" , \"Doe\" , 30 ), User . new ( 2 , \"Tifany\" , \"Doe\" , 31 ) ]; } } Testing \u00b6 Integration testing with resty & graphql is very easy due to fake server implementation. import { fakeHttpServer , FakeServerApi } from \"@typeix/resty\" ; import { AppModule } from \"~/app.module\" ; describe ( \"UserResolver\" , () => { let fakeServer : FakeServerApi ; beforeEach ( async () => { fakeServer = await fakeHttpServer ( AppModule ); }); describe ( \"Integration\" , () => { test ( \"GetUsers\" , async () => { let body = { \"query\" : ` query GetUsers { users { id, firstName, lastName, age } } ` }; let result = await fakeServer . POST ( \"/graphql\" , {}, Buffer . from ( JSON . stringify ( body )) ); expect ( JSON . parse ( result . getBody (). toString ())). toEqual ({ \"data\" : { \"users\" : [ { \"age\" : 30 , \"firstName\" : \"John\" , \"id\" : \"1\" , \"lastName\" : \"Doe\" }, { \"age\" : 31 , \"firstName\" : \"Tifany\" , \"id\" : \"2\" , \"lastName\" : \"Doe\" } ] } }); }); }); }); full working example can be found in resty starters repository .","title":"Quick Start"},{"location":"documentation/graphql/quick-start/#graphql","text":"Is a query language and runtime for APIs (Application Programming Interfaces) that provides a more flexible and efficient way to interact with web services compared to traditional RESTful APIs. Key characteristics of GraphQL include: Efficient Data Retrieval : With GraphQL, clients can request only the specific data they need, reducing over-fetching or under-fetching of information. This contrasts with traditional RESTful APIs, where endpoints often return fixed data structures. Single Endpoint : Unlike REST, which may require multiple endpoints for different resources, GraphQL typically exposes a single endpoint for all interactions. This simplifies API management and reduces the need for versioning. Strongly Typed Schema : GraphQL uses a schema to define the types of data available and the relationships between them. This schema serves as a contract between the client and server, ensuring that only valid queries are accepted. Nested Queries : Clients can request related data in a single query, allowing for deeply nested requests. This minimizes the need for multiple round-trips to the server. Real-time Updates : GraphQL can support real-time updates through subscriptions, enabling applications to receive instant notifications about changes in data. Introspection : Clients can query the schema itself, allowing for dynamic discovery of available types, queries, and mutations. This introspection capability is valuable for tooling and development. Versionless API : Since GraphQL clients can request exactly the data they need, there is less need for versioning of APIs. This can lead to more flexible and maintainable APIs. GraphQL is particularly well-suited for modern web and mobile applications, where data requirements can be dynamic and diverse. It has gained popularity in recent years and is supported by a vibrant community, along with tooling and libraries for various programming languages. While GraphQL offers significant benefits, it may not be the best choice for all scenarios, and the decision to use it should be based on the specific requirements and constraints of a given project.","title":"GraphQL"},{"location":"documentation/graphql/quick-start/#quick-start","text":"GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL combined with TypeScript helps you develop better type safety with your GraphQL queries, giving you end-to-end typing. See Comparison between GraphQL and REST. In this chapter, we assume a basic understanding of GraphQL, and focus on how to work with the Type-GraphQL module.","title":"Quick Start"},{"location":"documentation/graphql/quick-start/#installation","text":"Start by installing the required packages: $ npm i -g @typeix/cli $ typeix new grapql-project $ cd grapql-project $ npm i type-graphql graphql class-validator $ typeix start --watch Type-GraphQL offers two ways of building GraphQL applications, the code first and the schema first methods. You should choose the one that works best for you. Most of the chapters in this GraphQL section are divided into two main parts: one you should follow if you adopt code first, and the other to be used if you adopt schema first. Resty fully supports integration with type-graphql without any extra library or adapter. You can find full example in resty starters repository .","title":"Installation"},{"location":"documentation/graphql/quick-start/#resty-with-graphql","text":"Goal is to generate following structure: src L controllers L rest L test L user.controller.integration-spec.ts L permission.controller.integration-spec.ts L permission.controller.ts L user.controller.ts L graphql L test L permission.resolver.integration-spec.ts L user.resolver.integration-spec.ts L graphql.config.ts L graphql.controller.ts L user.resolver.ts L permission.resolver.ts L services L user.service.ts L permission.service.ts L app.module.ts L bootstrap.ts","title":"Resty with Graphql"},{"location":"documentation/graphql/quick-start/#schema-config","text":"In following example graphql.config.ts we need to use type-graphql to build schema, schema can be generated from code or from schema .gql file using graphql syntax, in schema config we need to declare all resolvers. import { CreateProvider , Injectable , RouterError } from \"@typeix/resty\" ; import { buildSchema } from \"type-graphql\" ; import { GraphQLSchema } from \"graphql\" ; import { UserResolver } from \"~/controllers/graphql/user.resolver\" ; import { PermissionResolver } from \"~/controllers/graphql/permission.resolver\" ; @Injectable () export class GraphQLConfig { @CreateProvider ({ provide : \"GraphqlConfigSchema\" , useFactory : async () => { return await buildSchema ({ resolvers : [ UserResolver , PermissionResolver ], container : ({ context }) => context . container }); }, providers : [] }) private schema : GraphQLSchema ; public getSchema () : GraphQLSchema { return this . schema ; } public parseBody ( body : Buffer ) : any { try { return JSON . parse ( body . toString ()); } catch ( e ) { throw new RouterError ( \"GraphQL syntax error, cannot parse json request\" , 400 ); } } }","title":"Schema config"},{"location":"documentation/graphql/quick-start/#controller","text":"In order for GraphQL to process request it needs to have only one REST endpoint which accepts request body as json which contains query operation name and variables, query can contain graphql query and mutations. It's important to provide all resolvers to graphql controller injection point, because that would create new instance of resolvers on each request. import { addRequestInterceptor , BodyAsBufferInterceptor , Controller , Inject , Injector , POST , RouterError } from \"@typeix/resty\" ; import { PermissionResolver } from \"~/controllers/graphql/permission.resolver\" ; import { UserResolver } from \"~/controllers/graphql/user.resolver\" ; import { GraphQLConfig } from \"~/controllers/graphql/graphql.config\" ; import { graphql , parse , Source , specifiedRules , validate } from \"graphql\" ; @Controller ({ path : \"/graphql\" , providers : [ PermissionResolver , UserResolver ], interceptors : [] }) export class GraphQLController { @Inject () graphQlConfig : GraphQLConfig ; @Inject () injector : Injector ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) processGraphQL ( @Inject () body : Buffer ) { let schema = this . graphQlConfig . getSchema (); let { query , operationName , variables } = this . graphQlConfig . parseBody ( body ); let source = new Source ( query , operationName ); let documentAST = parse ( source ); let validationErrors = validate ( schema , documentAST , specifiedRules ); if ( validationErrors . length > 0 ) { throw new RouterError ( \"GraphQL validation error.\" , 400 , validationErrors ); } return graphql ( schema , source , null , { container : this.injector }, variables , operationName ); } }","title":"Controller"},{"location":"documentation/graphql/quick-start/#resolvers","text":"Resolvers are like REST controllers, but it's based on graphql api and there you should define your queries and mutations. You can specify type of resolver or you can live out type on resolver and bind it to query or mutation. import { Inject , Injectable } from \"@typeix/resty\" ; import { Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) users () : Array < User > { return this . userService . find (); } } In following example we can see definition of user scalar type: @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field () age : number ; static new ( id : number , firstName : string , lastName : string , age : number ) : User { let obj = new User (); obj . id = id ; obj . firstName = firstName ; obj . lastName = lastName ; obj . age = age ; return obj ; } } User service data mock, normally we would call database to fetch data in service: import { Injectable } from \"@typeix/resty\" ; import { User } from \"~/data/user.entity\" ; @Injectable () export class UserService { find () : Array < User > { return [ User . new ( 1 , \"John\" , \"Doe\" , 30 ), User . new ( 2 , \"Tifany\" , \"Doe\" , 31 ) ]; } }","title":"Resolvers"},{"location":"documentation/graphql/quick-start/#testing","text":"Integration testing with resty & graphql is very easy due to fake server implementation. import { fakeHttpServer , FakeServerApi } from \"@typeix/resty\" ; import { AppModule } from \"~/app.module\" ; describe ( \"UserResolver\" , () => { let fakeServer : FakeServerApi ; beforeEach ( async () => { fakeServer = await fakeHttpServer ( AppModule ); }); describe ( \"Integration\" , () => { test ( \"GetUsers\" , async () => { let body = { \"query\" : ` query GetUsers { users { id, firstName, lastName, age } } ` }; let result = await fakeServer . POST ( \"/graphql\" , {}, Buffer . from ( JSON . stringify ( body )) ); expect ( JSON . parse ( result . getBody (). toString ())). toEqual ({ \"data\" : { \"users\" : [ { \"age\" : 30 , \"firstName\" : \"John\" , \"id\" : \"1\" , \"lastName\" : \"Doe\" }, { \"age\" : 31 , \"firstName\" : \"Tifany\" , \"id\" : \"2\" , \"lastName\" : \"Doe\" } ] } }); }); }); }); full working example can be found in resty starters repository .","title":"Testing"},{"location":"documentation/graphql/resolvers/","text":"Resolvers \u00b6 Resolvers are like rest controllers but they provide mapping to graphql operations: query, mutation into data. Big difference is that in REST you invoke for example 5 rest resource to do create,read,update,delete operations where in graphql we can execute 5 different operations on same graphql request resource. Queries \u00b6 Queries are used to fetch data and are meant to be read only operations, inside query operation we can implement custom filters. We need to use @Resolver decorator so that type-graphql can recognize that current class is resolver type. import { Inject , Injectable } from \"@typeix/resty\" ; import { Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) users () : Array < User > { return this . userService . find (); } } Resolvers need's to be referenced to schema builder and to graphql custom controller so that typeix dependency injecton can create UserResolver object and deliver it to graphql request, as it's provided example in quick-start we use create provider on service to create schema on application startup time. @CreateProvider ({ provide : \"GraphqlConfigSchema\" , useFactory : async () => { return await buildSchema ({ resolvers : [ UserResolver ], container : ({ context }) => context . container }); }, providers : [] }) and we provide provider info to controller so resty create those objects on request: @Controller ({ path : \"/graphql\" , providers : [ UserResolver ], interceptors : [] }) Arguments \u00b6 Usually, queries have some arguments - it might be the id of a resource, a search phrase or pagination settings. TypeGraphQL allows you to define arguments in two ways. Using @Arg() decorator we can inject value, we need to provide argument name and options if nullable or defaultValue for example. @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) users ( @Arg ( \"firstName\" , { nullable : true }) firstName : string ) : Array < User > { this . logger . debug ( `Injected argument: ${ firstName } ` ); return this . userService . findByName ( firstName ); } } Or we can simpy define argument type and inject argument type itself: @ArgsType () export class GetUserArgs { @Field ({ nullable : true }) firstName? : string ; @Field ({ nullable : true }) lastName? : string ; @Field ({ nullable : true }) age? : number ; } Now we can simply reference argument type in query using @Args() decorator and with destructuring syntax we gain access to single arguments as variables. @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) users ( @Args () { firstName , lastName , age } : GetUserArgs ) : Array < User > { this . logger . debug ( `Injected argument: ${ firstName } ` ); return this . userService . findByName ( firstName ); } } Interceptors \u00b6 With power of typeix dependency injection we can implement interceptors which are working with any method as long as object is created with Injector. Interceptors can be used to implement any custom logic and it can change result or behavior of method, for example Logging, Authorization. In following example we are going to implement logger Interceptor: import { createMethodInterceptor , Inject , Injectable , Interceptor , Logger , Method } from \"@typeix/resty\" ; @Injectable () class LoggerInterceptor implements Interceptor { @Inject () private logger : Logger ; async invoke ( method : Method ) : Promise < any > { let result = await method . invoke (); this . logger . debug ([ `Injected arguments: ${ this . prettyPrint ( method . methodArgs ) } ` , `Result ${ this . prettyPrint ( result ) } ` , `With decorator args: ${ this . prettyPrint ( method . decoratorArgs ) } ` ]. join ( \"\\n\" )); return result ; } private prettyPrint ( value : any ) : string { return JSON . stringify ( value , null , \" \" ); } } export function LogOutput ( value ) { return createMethodInterceptor ( LogOutput , LoggerInterceptor , { value }); } And now we can use interceptor in our resolvers by using custom defined @LogOutput() decorator. import { Inject , Injectable } from \"@typeix/resty\" ; import { Arg , Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; import { LogOutput } from \"~/controllers/graphql/logger.interceptor\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) @LogOutput ( \"Logging UserResolver Output\" ) users ( @Args () { firstName , lastName , age } : GetUserArgs ) : Array < User > { return this . userService . findByName ( firstName ); } } Example Log that is printed out is: [1649358777779] DEBUG (): Injected arguments: [ null ] Result [ { \"permissions\": [], \"id\": 1, \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30 }, { \"permissions\": [], \"id\": 2, \"firstName\": \"Tifany\", \"lastName\": \"Doe\", \"age\": 31 } ] With decorator args: { \"value\": \"Logging UserResolver Output\" } Field Resolvers \u00b6 Using @FieldResolver() provides you a way to extend current entity field with custom logic, for example we have database link, custom computed calculation like age from date of birth in User entity or to deliver permissions as lazy link In following example we can see how permissions are delivered as link to users, for each user it will invoke permissions resolver to deliver permissions data to user. import { Inject , Injectable , Logger } from \"@typeix/resty\" ; import { Arg , FieldResolver , Query , Resolver , Root } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; import { LogOutput } from \"~/controllers/graphql/logger.interceptor\" ; import { PermissionService } from \"~/services/permission.service\" ; import { Permission } from \"~/data/permission.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private permissionService : PermissionService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) @LogOutput ( \"Logging UserResolver.users\" ) users ( @Arg ( \"firstName\" , { nullable : true }) firstName : string ) : Array < User > { return this . userService . findByName ( firstName ); } @FieldResolver () @LogOutput ( \"Logging UserResolver.users.permissions\" ) permissions ( @Root () user : User ) : Array < Permission > { return this . permissionService . find ( user ); } } GraphQL Query that will deliver permissions nested to user and permissions by as separate grapql query query GetUsersAndPermissions { users { id , firstName , lastName , age , permissions { id , action } } permissions { id , action } } And in User entity we need to create permissions link: import { Field , ID , ObjectType } from \"type-graphql\" ; import { Permission } from \"~/data/permission.entity\" ; @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field () age : number ; @Field (() => [ Permission ]) permissions : Array < Permission > = []; }","title":"Resolvers"},{"location":"documentation/graphql/resolvers/#resolvers","text":"Resolvers are like rest controllers but they provide mapping to graphql operations: query, mutation into data. Big difference is that in REST you invoke for example 5 rest resource to do create,read,update,delete operations where in graphql we can execute 5 different operations on same graphql request resource.","title":"Resolvers"},{"location":"documentation/graphql/resolvers/#queries","text":"Queries are used to fetch data and are meant to be read only operations, inside query operation we can implement custom filters. We need to use @Resolver decorator so that type-graphql can recognize that current class is resolver type. import { Inject , Injectable } from \"@typeix/resty\" ; import { Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) users () : Array < User > { return this . userService . find (); } } Resolvers need's to be referenced to schema builder and to graphql custom controller so that typeix dependency injecton can create UserResolver object and deliver it to graphql request, as it's provided example in quick-start we use create provider on service to create schema on application startup time. @CreateProvider ({ provide : \"GraphqlConfigSchema\" , useFactory : async () => { return await buildSchema ({ resolvers : [ UserResolver ], container : ({ context }) => context . container }); }, providers : [] }) and we provide provider info to controller so resty create those objects on request: @Controller ({ path : \"/graphql\" , providers : [ UserResolver ], interceptors : [] })","title":"Queries"},{"location":"documentation/graphql/resolvers/#arguments","text":"Usually, queries have some arguments - it might be the id of a resource, a search phrase or pagination settings. TypeGraphQL allows you to define arguments in two ways. Using @Arg() decorator we can inject value, we need to provide argument name and options if nullable or defaultValue for example. @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) users ( @Arg ( \"firstName\" , { nullable : true }) firstName : string ) : Array < User > { this . logger . debug ( `Injected argument: ${ firstName } ` ); return this . userService . findByName ( firstName ); } } Or we can simpy define argument type and inject argument type itself: @ArgsType () export class GetUserArgs { @Field ({ nullable : true }) firstName? : string ; @Field ({ nullable : true }) lastName? : string ; @Field ({ nullable : true }) age? : number ; } Now we can simply reference argument type in query using @Args() decorator and with destructuring syntax we gain access to single arguments as variables. @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) users ( @Args () { firstName , lastName , age } : GetUserArgs ) : Array < User > { this . logger . debug ( `Injected argument: ${ firstName } ` ); return this . userService . findByName ( firstName ); } }","title":"Arguments"},{"location":"documentation/graphql/resolvers/#interceptors","text":"With power of typeix dependency injection we can implement interceptors which are working with any method as long as object is created with Injector. Interceptors can be used to implement any custom logic and it can change result or behavior of method, for example Logging, Authorization. In following example we are going to implement logger Interceptor: import { createMethodInterceptor , Inject , Injectable , Interceptor , Logger , Method } from \"@typeix/resty\" ; @Injectable () class LoggerInterceptor implements Interceptor { @Inject () private logger : Logger ; async invoke ( method : Method ) : Promise < any > { let result = await method . invoke (); this . logger . debug ([ `Injected arguments: ${ this . prettyPrint ( method . methodArgs ) } ` , `Result ${ this . prettyPrint ( result ) } ` , `With decorator args: ${ this . prettyPrint ( method . decoratorArgs ) } ` ]. join ( \"\\n\" )); return result ; } private prettyPrint ( value : any ) : string { return JSON . stringify ( value , null , \" \" ); } } export function LogOutput ( value ) { return createMethodInterceptor ( LogOutput , LoggerInterceptor , { value }); } And now we can use interceptor in our resolvers by using custom defined @LogOutput() decorator. import { Inject , Injectable } from \"@typeix/resty\" ; import { Arg , Query , Resolver } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; import { LogOutput } from \"~/controllers/graphql/logger.interceptor\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Query (()=> [ User ]) @LogOutput ( \"Logging UserResolver Output\" ) users ( @Args () { firstName , lastName , age } : GetUserArgs ) : Array < User > { return this . userService . findByName ( firstName ); } } Example Log that is printed out is: [1649358777779] DEBUG (): Injected arguments: [ null ] Result [ { \"permissions\": [], \"id\": 1, \"firstName\": \"John\", \"lastName\": \"Doe\", \"age\": 30 }, { \"permissions\": [], \"id\": 2, \"firstName\": \"Tifany\", \"lastName\": \"Doe\", \"age\": 31 } ] With decorator args: { \"value\": \"Logging UserResolver Output\" }","title":"Interceptors"},{"location":"documentation/graphql/resolvers/#field-resolvers","text":"Using @FieldResolver() provides you a way to extend current entity field with custom logic, for example we have database link, custom computed calculation like age from date of birth in User entity or to deliver permissions as lazy link In following example we can see how permissions are delivered as link to users, for each user it will invoke permissions resolver to deliver permissions data to user. import { Inject , Injectable , Logger } from \"@typeix/resty\" ; import { Arg , FieldResolver , Query , Resolver , Root } from \"type-graphql\" ; import { UserService } from \"~/services/user.service\" ; import { User } from \"~/data/user.entity\" ; import { LogOutput } from \"~/controllers/graphql/logger.interceptor\" ; import { PermissionService } from \"~/services/permission.service\" ; import { Permission } from \"~/data/permission.entity\" ; @Injectable () @Resolver ( User ) export class UserResolver { @Inject () private userService : UserService ; @Inject () private permissionService : PermissionService ; @Inject () private logger : Logger ; @Query (()=> [ User ]) @LogOutput ( \"Logging UserResolver.users\" ) users ( @Arg ( \"firstName\" , { nullable : true }) firstName : string ) : Array < User > { return this . userService . findByName ( firstName ); } @FieldResolver () @LogOutput ( \"Logging UserResolver.users.permissions\" ) permissions ( @Root () user : User ) : Array < Permission > { return this . permissionService . find ( user ); } } GraphQL Query that will deliver permissions nested to user and permissions by as separate grapql query query GetUsersAndPermissions { users { id , firstName , lastName , age , permissions { id , action } } permissions { id , action } } And in User entity we need to create permissions link: import { Field , ID , ObjectType } from \"type-graphql\" ; import { Permission } from \"~/data/permission.entity\" ; @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field () age : number ; @Field (() => [ Permission ]) permissions : Array < Permission > = []; }","title":"Field Resolvers"},{"location":"documentation/graphql/scalars/","text":"","title":"GraphQL - Scalars"},{"location":"documentation/graphql/subscriptions/","text":"","title":"GraphQL - Subscriptions"},{"location":"documentation/graphql/types-and-fields/","text":"With Typescript we can easily map entities with GraphQL schema definitions. Fields \u00b6 Let's start by defining User entity: class User { id : number ; firstName : string ; lastName : string ; age : number ; } In order for type-graphql to recognize types we have to use following decorators @ObjectType to make entity visible to type-graphql and @Field decorator to declare graphql properties. @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field (() => Int ) age : number ; } Which will create following GraphQL schema in SDL: type User { id : ID ! firstName : String ! lastName : String ! age : Int ! } Types \u00b6 GraphQL supports scalar (ID, Int, Float, String, Boolean), objects and enums types. For Arrays we use the explicit [] array literal notation @Field(() => [Type]) . For nested arrays, we just use the explicit [ ] notation to determine the depth of the array, e.g. @Field(() => [[Type]]) would tell the compiler we expect an integer array of depth 2. For Object we just reference object type @Field(() => Type) . Nullables you can define in two ways, one is to override default behavior in schema build options nullableByDefault: true but we recommend explicitly defining optional property. @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field (() => Int , { nullable : true }) age? : number ; } As you can see in example above we are using optional age property and we are explicitly defining options for that field. Basic possible options are defined by FieldOptions interface. interface FieldOptions { nullable? : boolean | \"items\" | \"itemsAndList\" ; defaultValue? : any ; description? : string ; name? : string ; // Schema name complexity? : number ; } Be aware that defining constructors is strictly forbidden on type graphql entites and we shouldn't use them there, as TypeGraphQL creates instances of object type classes under the hood by itself.","title":"Types and Fields"},{"location":"documentation/graphql/types-and-fields/#fields","text":"Let's start by defining User entity: class User { id : number ; firstName : string ; lastName : string ; age : number ; } In order for type-graphql to recognize types we have to use following decorators @ObjectType to make entity visible to type-graphql and @Field decorator to declare graphql properties. @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field (() => Int ) age : number ; } Which will create following GraphQL schema in SDL: type User { id : ID ! firstName : String ! lastName : String ! age : Int ! }","title":"Fields"},{"location":"documentation/graphql/types-and-fields/#types","text":"GraphQL supports scalar (ID, Int, Float, String, Boolean), objects and enums types. For Arrays we use the explicit [] array literal notation @Field(() => [Type]) . For nested arrays, we just use the explicit [ ] notation to determine the depth of the array, e.g. @Field(() => [[Type]]) would tell the compiler we expect an integer array of depth 2. For Object we just reference object type @Field(() => Type) . Nullables you can define in two ways, one is to override default behavior in schema build options nullableByDefault: true but we recommend explicitly defining optional property. @ObjectType () export class User { @Field (() => ID ) id : number ; @Field () firstName : string ; @Field () lastName : string ; @Field (() => Int , { nullable : true }) age? : number ; } As you can see in example above we are using optional age property and we are explicitly defining options for that field. Basic possible options are defined by FieldOptions interface. interface FieldOptions { nullable? : boolean | \"items\" | \"itemsAndList\" ; defaultValue? : any ; description? : string ; name? : string ; // Schema name complexity? : number ; } Be aware that defining constructors is strictly forbidden on type graphql entites and we shouldn't use them there, as TypeGraphQL creates instances of object type classes under the hood by itself.","title":"Types"},{"location":"documentation/graphql/unions-and-enums/","text":"","title":"GraphQL - Unions & Enums"},{"location":"documentation/rest/controllers/","text":"Controllers \u00b6 Controllers are responsible for handling incoming requests and returning responses to the client, on each request new controller instance is created. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions. In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata. @Controller(metadata: IControllerMetadata) decorator, is required to define a basic controller. path - actual routing path interceptors - controller level request interceptors providers - providers which are created on each request export interface IControllerMetadata { path : string ; interceptors? : Array < RequestInterceptorConstructor > ; providers? : Array < IProvider | Function > ; } Routing \u00b6 In an example below we will create a @Controller() with route path of customers. Using a path in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /customers. In that case, we could specify the path customers in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file. import { Controller , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @GET () findAll () { return \"This action returns all customers\" ; } } @GET() HTTP request method decorator before the findAll() method tells Resty to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method ( GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the declared for the controller, and any path specified in the request decorator. Since we've declared a prefix for every route customers, and haven't added any path information in the decorator, Typeix will map GET /customers requests to this handler. A path of customers combined with the decorator @GET(\"profile\") would produce a route mapping for requests like GET /customers/profile . In our example above, when a GET request is made to this endpoint, Resty routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Resty doesn't attach any significance to the method name chosen. Request Object \u00b6 Resty is a lightweight wrapper around http, https, http2 server, framework provides you access to request and response objects via dependency Injection. import { Controller , GET , Inject } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @GET () findAll () { return this . customerService . findAll (); } } Those are native node.js request and response objects. Resources \u00b6 Earlier, we defined an endpoint to fetch the customer resource (GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler: import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @GET () findAll () { return this . customerService . findAll (); } @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { const entity = JSON . parse ( body . toString ()); return this . customerService . create ( entity ); } } Resty provides decorators for standard HTTP methods: @GET() , @POST() , @PUT() , @DELETE() , @PATCH() , @OPTIONS() , @HEAD() , @TRACE() and @CONNECT() . In addition @OnError(\"*\") defines route for a custom error handler on any route that handles all of them. Resty supports custom error handlers on any route, you just need to define witch matches. Path Params \u00b6 Resty supports any regex patterns in defining routes including name capturing regexes as path params which are unsupported in javascript. Routes are defined by resty in order (one to nth) route, routes are also executed by resty in that order. import { Controller , GET , Inject , BodyAsBufferInterceptor , PathParam } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET ( \"/<id:(\\\\d+)>/<type:(\\\\w+)>\" ) findByIdAndType ( @PathParam ( \"id\" ) id : number , @PathParam ( \"type\" ) customerType : string ) { return this . customerService . findByIdAndType ( id , customerType ); } @GET ( \"/blog/<path:(.*)>\" ) findPage ( @PathParam ( \"path\" ) path : string ) { return this . customerService . findBlogPostByPath ( path ); } } As you can see above you can define custom name capturing as path params, however you don't necessary need to define name capturing to use regex. Status code and Headers \u00b6 Changing status codes can easily be done via low level node.js api, or you can simply create custom DI method interceptors for that. import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { this . response . setHeader ( \"Cache-Control\" , \"none\" ); const entity = JSON . parse ( body . toString ()); const result = this . customerService . create ( entity ); this . response . writeHead ( 200 , { \"Content-Type\" : \"text/plain\" }); return result ; } } Creating decorators as method interceptors to provide nicer custom api can be done with a power of Typeix dependency injection. In example below you can find a custom method interceptor in which you can inject any of your custom service: import { Injectable , Inject , Interceptor , Method , createMethodInterceptor , isObject , isString } from \"@typeix/resty\" ; import { ServerResponse } from \"http\" ; @Injectable () class SetHeaderInterceptor implements Interceptor { @Inject () response : ServerResponse ; invoke ( method : Method ) : any { if ( isObject ( method . decoratorArgs . key )) { Object . keys ( method . decoratorArgs . key ). forEach ( key => { this . response . setHeader ( key , Reflect . get ( method . decoratorArgs . key , key )); }); } else if ( isString ( method . decoratorArgs . key ) && isString ( method . decoratorArgs . value )) { this . response . setHeader ( method . decoratorArgs . key , method . decoratorArgs . value ); } } } After defining interceptor we need to define custom decorator: export function SetHeader ( key : string | {[ key : string ] : string }, value? : string ) { return createMethodInterceptor ( SetHeader , SetHeaderInterceptor , { key , value }); } Simple usage of custom decorators in controllers: import { Controller , GET , Inject , BodyAsBufferInterceptor , addRequestInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @POST () @SetHeader ({ \"Cache-Control\" : \"none\" , \"Content-Type\" : \"application/json\" }) @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { return this . customerService . create ( entity ); } } As you can see above it eliminates repeatable code and provides you nice and clean custom api! Redirection \u00b6 Redirections can as well be done via low level API or you can create custom method interceptor! import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @GET () redirect () { this . response . setHeader ( \"Location\" , \"/mypage\" ); this . response . writeHead ( 307 ); this . response . end (); } } Async Executions \u00b6 By default, all requests can return async or sync results, Typeix know how to handle them, same rule apply to DI and Resty interceptors. import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () syncResult () { return { message : \"This is an sync way\" } } @GET ( \"/async\" ) async asyncResult () : Promise < any > { const customer = await this . customerService . findOne (); return { message : \"This is an nice customer\" , customer } } } Request Payloads \u00b6 In example below you can see how simple it is to get body as buffer with built in request interceptor BodyAsBufferInterceptor : import { Controller , GET , Inject , BodyAsBufferInterceptor , addRequestInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { const entity = JSON . parse ( body . toString ()); return this . customerService . create ( entity ); } }","title":"Controllers"},{"location":"documentation/rest/controllers/#controllers","text":"Controllers are responsible for handling incoming requests and returning responses to the client, on each request new controller instance is created. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions. In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata. @Controller(metadata: IControllerMetadata) decorator, is required to define a basic controller. path - actual routing path interceptors - controller level request interceptors providers - providers which are created on each request export interface IControllerMetadata { path : string ; interceptors? : Array < RequestInterceptorConstructor > ; providers? : Array < IProvider | Function > ; }","title":"Controllers"},{"location":"documentation/rest/controllers/#routing","text":"In an example below we will create a @Controller() with route path of customers. Using a path in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /customers. In that case, we could specify the path customers in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file. import { Controller , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @GET () findAll () { return \"This action returns all customers\" ; } } @GET() HTTP request method decorator before the findAll() method tells Resty to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method ( GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the declared for the controller, and any path specified in the request decorator. Since we've declared a prefix for every route customers, and haven't added any path information in the decorator, Typeix will map GET /customers requests to this handler. A path of customers combined with the decorator @GET(\"profile\") would produce a route mapping for requests like GET /customers/profile . In our example above, when a GET request is made to this endpoint, Resty routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Resty doesn't attach any significance to the method name chosen.","title":"Routing"},{"location":"documentation/rest/controllers/#request-object","text":"Resty is a lightweight wrapper around http, https, http2 server, framework provides you access to request and response objects via dependency Injection. import { Controller , GET , Inject } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @GET () findAll () { return this . customerService . findAll (); } } Those are native node.js request and response objects.","title":"Request Object"},{"location":"documentation/rest/controllers/#resources","text":"Earlier, we defined an endpoint to fetch the customer resource (GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler: import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @GET () findAll () { return this . customerService . findAll (); } @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { const entity = JSON . parse ( body . toString ()); return this . customerService . create ( entity ); } } Resty provides decorators for standard HTTP methods: @GET() , @POST() , @PUT() , @DELETE() , @PATCH() , @OPTIONS() , @HEAD() , @TRACE() and @CONNECT() . In addition @OnError(\"*\") defines route for a custom error handler on any route that handles all of them. Resty supports custom error handlers on any route, you just need to define witch matches.","title":"Resources"},{"location":"documentation/rest/controllers/#path-params","text":"Resty supports any regex patterns in defining routes including name capturing regexes as path params which are unsupported in javascript. Routes are defined by resty in order (one to nth) route, routes are also executed by resty in that order. import { Controller , GET , Inject , BodyAsBufferInterceptor , PathParam } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET ( \"/<id:(\\\\d+)>/<type:(\\\\w+)>\" ) findByIdAndType ( @PathParam ( \"id\" ) id : number , @PathParam ( \"type\" ) customerType : string ) { return this . customerService . findByIdAndType ( id , customerType ); } @GET ( \"/blog/<path:(.*)>\" ) findPage ( @PathParam ( \"path\" ) path : string ) { return this . customerService . findBlogPostByPath ( path ); } } As you can see above you can define custom name capturing as path params, however you don't necessary need to define name capturing to use regex.","title":"Path Params"},{"location":"documentation/rest/controllers/#status-code-and-headers","text":"Changing status codes can easily be done via low level node.js api, or you can simply create custom DI method interceptors for that. import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { this . response . setHeader ( \"Cache-Control\" , \"none\" ); const entity = JSON . parse ( body . toString ()); const result = this . customerService . create ( entity ); this . response . writeHead ( 200 , { \"Content-Type\" : \"text/plain\" }); return result ; } } Creating decorators as method interceptors to provide nicer custom api can be done with a power of Typeix dependency injection. In example below you can find a custom method interceptor in which you can inject any of your custom service: import { Injectable , Inject , Interceptor , Method , createMethodInterceptor , isObject , isString } from \"@typeix/resty\" ; import { ServerResponse } from \"http\" ; @Injectable () class SetHeaderInterceptor implements Interceptor { @Inject () response : ServerResponse ; invoke ( method : Method ) : any { if ( isObject ( method . decoratorArgs . key )) { Object . keys ( method . decoratorArgs . key ). forEach ( key => { this . response . setHeader ( key , Reflect . get ( method . decoratorArgs . key , key )); }); } else if ( isString ( method . decoratorArgs . key ) && isString ( method . decoratorArgs . value )) { this . response . setHeader ( method . decoratorArgs . key , method . decoratorArgs . value ); } } } After defining interceptor we need to define custom decorator: export function SetHeader ( key : string | {[ key : string ] : string }, value? : string ) { return createMethodInterceptor ( SetHeader , SetHeaderInterceptor , { key , value }); } Simple usage of custom decorators in controllers: import { Controller , GET , Inject , BodyAsBufferInterceptor , addRequestInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @Inject () customerService : CustomerService ; @POST () @SetHeader ({ \"Cache-Control\" : \"none\" , \"Content-Type\" : \"application/json\" }) @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { return this . customerService . create ( entity ); } } As you can see above it eliminates repeatable code and provides you nice and clean custom api!","title":"Status code and Headers"},{"location":"documentation/rest/controllers/#redirection","text":"Redirections can as well be done via low level API or you can create custom method interceptor! import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () response : ServerResponse ; @Inject () request : IncomingMessage ; @GET () redirect () { this . response . setHeader ( \"Location\" , \"/mypage\" ); this . response . writeHead ( 307 ); this . response . end (); } }","title":"Redirection"},{"location":"documentation/rest/controllers/#async-executions","text":"By default, all requests can return async or sync results, Typeix know how to handle them, same rule apply to DI and Resty interceptors. import { Controller , GET , Inject , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () syncResult () { return { message : \"This is an sync way\" } } @GET ( \"/async\" ) async asyncResult () : Promise < any > { const customer = await this . customerService . findOne (); return { message : \"This is an nice customer\" , customer } } }","title":"Async Executions"},{"location":"documentation/rest/controllers/#request-payloads","text":"In example below you can see how simple it is to get body as buffer with built in request interceptor BodyAsBufferInterceptor : import { Controller , GET , Inject , BodyAsBufferInterceptor , addRequestInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse } from \"http\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) create ( @Inject () body : Buffer ) { const entity = JSON . parse ( body . toString ()); return this . customerService . create ( entity ); } }","title":"Request Payloads"},{"location":"documentation/rest/interceptors/","text":"Interceptors \u00b6 What is interceptor? Interceptor is a class annotated with @Injectable which have access to intercepted methods, it can control execution, catch exceptions, bind extra logic and transform data that are returned in original method. Typeix support two type of interceptors, a request interceptor and dependency injection interceptor. Request \u00b6 Request interceptors are implemented in resty framework package and thy can be used only with resty. Executed in order Is request scoped Can be assigned at controller level Can be defined at singe request level First return wins - if you have multiple interceptors at controller level, first one in order that returns result will stop execution of other interceptors! interface InterceptedRequest { handler : () => any ; injector : Injector ; route : IResolvedRoute ; request : IncomingMessage | Http2ServerRequest ; response : ServerResponse | Http2ServerResponse ; args : any ; } Caching interceptor example: import { Injectable , Inject , RequestInterceptor , InterceptedRequest } from \"@typeix/resty\" ; @Injectable () export class CacheInterceptor implements RequestInterceptor { @Inject () cacheProvider : InMemoryCache ; async invoke ( method : InterceptedRequest ) : Promise < any > { if ( await this . cacheProvider . has ( method . route . path )) { return await this . cacheProvider . get ( method . route . path ); } else { this . cacheProvider . set ( method . route . path , await method . handler (), 120 ); } } } Controller implementation: import { Controller , PathParam } from \"@typeix/resty\" ; @Controller ({ interceptors : [ CacheInterceptor ] }) export class PostsController { @Render ( \"posts\" ) @GET ( \"/<path:(.*)>\" ) getPost ( @PathParam ( \"path\" ) path : string ) { return this . postsService . getPostsByPath ( path ); } } Method \u00b6 Method interceptors are implemented in dependency injection package, and it can be used with Injector. Executed in order All interceptors are executed Return can be transformed Can be defined at any method (service, module, controller etc.) interface Method { invoke : () => any ; transform : ( data : any ) => any ; readonly injector : Injector ; readonly decoratorArgs : any ; } Typeix is un opinionated framework, and it's not bundled with any templating engine, in order to use any templating engine you need to install it, create a service and using handy decorator you can remove boilerplate code! @Injectable () export class RenderInterceptor implements Interceptor { @Inject () engine : TemplateEngine ; async invoke ( method : Method ) : Promise < any > { const data = await method . invoke (); const result = await this . engine . compileAndRender ( method . decoratorArgs . value , data ); return await method . transform ( result ); } } export function Render ( value : string ) { return createMethodInterceptor ( Render , RenderInterceptor , { value }); } Setting header use case: import { Injectable , Inject , Interceptor , Method , createMethodInterceptor , isObject , isString } from \"@typeix/resty\" ; import { ServerResponse } from \"http\" ; @Injectable () class SetHeaderInterceptor implements Interceptor { @Inject () response : ServerResponse ; invoke ( method : Method ) : any { if ( isObject ( method . decoratorArgs . key )) { Object . keys ( method . decoratorArgs . key ). forEach ( key => { this . response . setHeader ( key , Reflect . get ( method . decoratorArgs . key , key )); }); } else if ( isString ( method . decoratorArgs . key ) && isString ( method . decoratorArgs . value )) { this . response . setHeader ( method . decoratorArgs . key , method . decoratorArgs . value ); } } } After defining interceptor we need to define custom decorator: export function SetHeader ( key : string | {[ key : string ] : string }, value? : string ) { return createMethodInterceptor ( SetHeader , SetHeaderInterceptor , { key , value }); }","title":"Interceptors"},{"location":"documentation/rest/interceptors/#interceptors","text":"What is interceptor? Interceptor is a class annotated with @Injectable which have access to intercepted methods, it can control execution, catch exceptions, bind extra logic and transform data that are returned in original method. Typeix support two type of interceptors, a request interceptor and dependency injection interceptor.","title":"Interceptors"},{"location":"documentation/rest/interceptors/#request","text":"Request interceptors are implemented in resty framework package and thy can be used only with resty. Executed in order Is request scoped Can be assigned at controller level Can be defined at singe request level First return wins - if you have multiple interceptors at controller level, first one in order that returns result will stop execution of other interceptors! interface InterceptedRequest { handler : () => any ; injector : Injector ; route : IResolvedRoute ; request : IncomingMessage | Http2ServerRequest ; response : ServerResponse | Http2ServerResponse ; args : any ; } Caching interceptor example: import { Injectable , Inject , RequestInterceptor , InterceptedRequest } from \"@typeix/resty\" ; @Injectable () export class CacheInterceptor implements RequestInterceptor { @Inject () cacheProvider : InMemoryCache ; async invoke ( method : InterceptedRequest ) : Promise < any > { if ( await this . cacheProvider . has ( method . route . path )) { return await this . cacheProvider . get ( method . route . path ); } else { this . cacheProvider . set ( method . route . path , await method . handler (), 120 ); } } } Controller implementation: import { Controller , PathParam } from \"@typeix/resty\" ; @Controller ({ interceptors : [ CacheInterceptor ] }) export class PostsController { @Render ( \"posts\" ) @GET ( \"/<path:(.*)>\" ) getPost ( @PathParam ( \"path\" ) path : string ) { return this . postsService . getPostsByPath ( path ); } }","title":"Request"},{"location":"documentation/rest/interceptors/#method","text":"Method interceptors are implemented in dependency injection package, and it can be used with Injector. Executed in order All interceptors are executed Return can be transformed Can be defined at any method (service, module, controller etc.) interface Method { invoke : () => any ; transform : ( data : any ) => any ; readonly injector : Injector ; readonly decoratorArgs : any ; } Typeix is un opinionated framework, and it's not bundled with any templating engine, in order to use any templating engine you need to install it, create a service and using handy decorator you can remove boilerplate code! @Injectable () export class RenderInterceptor implements Interceptor { @Inject () engine : TemplateEngine ; async invoke ( method : Method ) : Promise < any > { const data = await method . invoke (); const result = await this . engine . compileAndRender ( method . decoratorArgs . value , data ); return await method . transform ( result ); } } export function Render ( value : string ) { return createMethodInterceptor ( Render , RenderInterceptor , { value }); } Setting header use case: import { Injectable , Inject , Interceptor , Method , createMethodInterceptor , isObject , isString } from \"@typeix/resty\" ; import { ServerResponse } from \"http\" ; @Injectable () class SetHeaderInterceptor implements Interceptor { @Inject () response : ServerResponse ; invoke ( method : Method ) : any { if ( isObject ( method . decoratorArgs . key )) { Object . keys ( method . decoratorArgs . key ). forEach ( key => { this . response . setHeader ( key , Reflect . get ( method . decoratorArgs . key , key )); }); } else if ( isString ( method . decoratorArgs . key ) && isString ( method . decoratorArgs . value )) { this . response . setHeader ( method . decoratorArgs . key , method . decoratorArgs . value ); } } } After defining interceptor we need to define custom decorator: export function SetHeader ( key : string | {[ key : string ] : string }, value? : string ) { return createMethodInterceptor ( SetHeader , SetHeaderInterceptor , { key , value }); }","title":"Method"},{"location":"documentation/rest/modules/","text":"Modules \u00b6 Each resty application needs to have only one @RootModule and it can have arbitrary number of @Modules which are imported at other modules or at root module definition. A module is a class annotated with a @Module() or @RootModule() decorator. You can find about module package specifics in @typeix/modules package. However Resty framework have extra module specifics which are implemented on top of @typeix/modules implementation. There are two types of resty modules a module and a root module: interface ModuleMetadata { imports? : Array < Function | IProvider > ; exports? : Array < Function | IProvider > ; controllers? : Array < Function | IProvider > ; path? : string ; providers : Array < Function | IProvider > ; } A @Module is a module which is imported by other module or by @RootModule . A @RootModule is used only once in application, and it needs to be used by resty pipeServer function! interface RootModuleMetadata extends ModuleMetadata { controllers : Array < Function | IProvider > ; shared_providers? : Array < Function | IProvider > ; } Feature modules \u00b6 Feature modules are modules which are belonging to same application domain, specific business feature and helps to keep code more organized, manage complexity and to implement SOLID principles. Let's take a look at one example: src L modules L admin L services L admin.service.ts L controllers L admin.controller.ts L admin.module.ts Admin service: import { Injectable } from \"@typeix/resty\" ; @Injectable () export class AdminService { } Admin controller: import { Module } from \"@typeix/resty\" ; @Controller ({ path : \"/\" }) export class AdminController { } Admin module: import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , controllers : [ AdminController ], providers : [ AdminService ] }) export class AdminModule { } Root Module Definition: import { Module } from \"@typeix/resty\" ; import { AdminModule } from \"./modules/admin/admin.module\" ; @Module ({ imports : [ AdminModule ] }) export class ApplicationModule { } Sharing Providers \u00b6 It's possible to share providers between modules in two ways, globally by defining them in @RootModule or locally by exporting providers inside of module. In following example AdminService is exported to other module which imports this module! import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , controllers : [ AdminController ], providers : [ AdminService ], exports : [ AdminService ] }) export class AdminModule { } We can as well share providers inside of root module, but keep in mind that change is actually making that provider visible to all modules! Root Module Definition: import { Module } from \"@typeix/resty\" ; import { AdminService } from \"./modules/admin/services/admin.service\" ; @Module ({ shared_providers : [ AdminService ] }) export class ApplicationModule { } Module exporting \u00b6 It's possible to share providers by importing and exporting providers from modules. Providers that must be exported to other modules needs to be defined in exports metadata inside of module metadata. import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , providers : [ AdminService ], exports : [ AdminService ] }) export class AdminModule { } Once module exports providers that wants to export, module that imports GuestModule must define imports or modules to be imported! If you want that same service is re-exported it's possible to re-export by defining provider exports to imported module! import { Module } from \"@typeix/resty\" ; import { AdminModule } from \"./modules/admin/admin.module\" ; import { AdminService } from \"./modules/admin/services/admin.service\" ; @Module ({ path : \"/guest\" , imports : [ AdminModule ], exports : [ AdminService ] }) export class GuestModule { } Dynamic modules \u00b6 Resty framework supports dynamic modules and controllers via resty routing, but we will tackle this topic in routing documentation!","title":"Modules"},{"location":"documentation/rest/modules/#modules","text":"Each resty application needs to have only one @RootModule and it can have arbitrary number of @Modules which are imported at other modules or at root module definition. A module is a class annotated with a @Module() or @RootModule() decorator. You can find about module package specifics in @typeix/modules package. However Resty framework have extra module specifics which are implemented on top of @typeix/modules implementation. There are two types of resty modules a module and a root module: interface ModuleMetadata { imports? : Array < Function | IProvider > ; exports? : Array < Function | IProvider > ; controllers? : Array < Function | IProvider > ; path? : string ; providers : Array < Function | IProvider > ; } A @Module is a module which is imported by other module or by @RootModule . A @RootModule is used only once in application, and it needs to be used by resty pipeServer function! interface RootModuleMetadata extends ModuleMetadata { controllers : Array < Function | IProvider > ; shared_providers? : Array < Function | IProvider > ; }","title":"Modules"},{"location":"documentation/rest/modules/#feature-modules","text":"Feature modules are modules which are belonging to same application domain, specific business feature and helps to keep code more organized, manage complexity and to implement SOLID principles. Let's take a look at one example: src L modules L admin L services L admin.service.ts L controllers L admin.controller.ts L admin.module.ts Admin service: import { Injectable } from \"@typeix/resty\" ; @Injectable () export class AdminService { } Admin controller: import { Module } from \"@typeix/resty\" ; @Controller ({ path : \"/\" }) export class AdminController { } Admin module: import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , controllers : [ AdminController ], providers : [ AdminService ] }) export class AdminModule { } Root Module Definition: import { Module } from \"@typeix/resty\" ; import { AdminModule } from \"./modules/admin/admin.module\" ; @Module ({ imports : [ AdminModule ] }) export class ApplicationModule { }","title":"Feature modules"},{"location":"documentation/rest/modules/#sharing-providers","text":"It's possible to share providers between modules in two ways, globally by defining them in @RootModule or locally by exporting providers inside of module. In following example AdminService is exported to other module which imports this module! import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , controllers : [ AdminController ], providers : [ AdminService ], exports : [ AdminService ] }) export class AdminModule { } We can as well share providers inside of root module, but keep in mind that change is actually making that provider visible to all modules! Root Module Definition: import { Module } from \"@typeix/resty\" ; import { AdminService } from \"./modules/admin/services/admin.service\" ; @Module ({ shared_providers : [ AdminService ] }) export class ApplicationModule { }","title":"Sharing Providers"},{"location":"documentation/rest/modules/#module-exporting","text":"It's possible to share providers by importing and exporting providers from modules. Providers that must be exported to other modules needs to be defined in exports metadata inside of module metadata. import { Module } from \"@typeix/resty\" ; import { AdminController } from \"./controllers/admin.controller\" ; import { AdminService } from \"./services/admin.service\" ; @Module ({ path : \"/admin\" , providers : [ AdminService ], exports : [ AdminService ] }) export class AdminModule { } Once module exports providers that wants to export, module that imports GuestModule must define imports or modules to be imported! If you want that same service is re-exported it's possible to re-export by defining provider exports to imported module! import { Module } from \"@typeix/resty\" ; import { AdminModule } from \"./modules/admin/admin.module\" ; import { AdminService } from \"./modules/admin/services/admin.service\" ; @Module ({ path : \"/guest\" , imports : [ AdminModule ], exports : [ AdminService ] }) export class GuestModule { }","title":"Module exporting"},{"location":"documentation/rest/modules/#dynamic-modules","text":"Resty framework supports dynamic modules and controllers via resty routing, but we will tackle this topic in routing documentation!","title":"Dynamic modules"},{"location":"documentation/rest/providers/","text":"Providers \u00b6 Dependencies are services or objects that a class needs to perform its function.x Providers are a fundamental concept in Typeix Dependency Injection, Typeix uses @typeix/di package which is delivered and exported directly with @typeix/resty package. Providers are basically classes decorated with @Injectable() decorator which are used by DI system to create those objects on application bootstrap or on request instance, basically you need to define @Controller() provider if you want that your provider is created at request level. All other @Module() providers are created at application bootstrap! There are three type of providers class, value and factory provider, functions inside providers array are converted to class providers. There are three types of providers in total: {provde, useClass} is a class provider. {provde, useFactory} is a factory provider. {provde, useValue} is a value provider. Dependent providers?: Array<Function | IProvider> inside of provider (class and factory) are extra dependencies that are created before provider and delivered as dependencies to provider itself. interface IProvider { provide : any ; useValue? : any ; useClass? : Function ; useFactory? : Function ; providers? : Array < Function | IProvider > ; } Scopes \u00b6 Resty provides two scopes of providers, providers which are created at bootstrap time or also known as application providers and providers that are created at each request are request providers. Big difference is that application providers are singletons where request provider is created and injected at each controller request! Application \u00b6 In code below you can see application scope created services: import { Injectable , Module , Controller , Inject , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () findAll () { return \"This action returns all customers\" ; } } As you can see CustomerService is provided within module providers that means that CustomerService class will be created at application bootstrap time and always provided as singleton object. @Injectable () export class CustomerService { @Inject () dataStore : DataStore ; findAll () { return this . dataStore . query ( \"SELECT * FROM Customers\" ); } } @Module ({ controllers : [ CustomerController ], providers : [ CustomerService ] }) export class ApplicationModule { } Request \u00b6 However it's possible to create request scoped providers by simply providing them as controller providers. All request scope providers are memory safe, that means that those objects are automatically cleaned up when response body is sent to client! So in that case you don't need to take care if you actually are pushing some data inside service context as long as they are not referenced to some live objects everything is automatically garbage collected. import { Injectable , Module , Controller , Inject , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" , providers : [ CustomerService ] }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () findAll () { return \"This action returns all customers\" ; } } @Module ({ controllers : [ CustomerController ] }) export class ApplicationModule {} Injection Points \u00b6 Once your provider is created by dependency injection system you can use @Inject() decorator to deliver your object instance to arbitrary provider. Property Injection \u00b6 @Inject(token: Type) decorator is used to inject dependency at property injection point. If you provide token type, DI will ignore type of property, so in example below we can se that @Inject(CustomerService) will actually inject CustomerService for iCustomerService property, all injected properties are created on object context, they are not created on prototype of object! Prototype holds only metadata information! @Inject() customerService: CustomerService; typeix di will inject correct type as long as property is actual object type and not an interface! import { Controller , Inject } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @Inject ( CustomerService ) iCustomerService : InterfaceCustomerService ; } Parameter Injection \u00b6 All parameter injections are method scoped, and only visible to actual method! Keep in mind that property injection points are delivered at object creation where parameters are delivered to method at actual method invocation. import { Controller } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { indexAction ( @Inject () customerService : CustomerService ) { } } Create Provider \u00b6 If you want that your provider is created at creation time, you can use @CreateProvider(Function | IProvider) decorator to automatically create provider for you inside of Service, Controller, Module or Interceptor! It works with all three provider types! import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider () customerService : CustomerService ; } Factory Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useFactory : ( a , b ) => { return new CustomerService ( a , b ); }, providers : [ ProviderA , ProviderB ] }) customerService : CustomerService ; } Value Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; const singleton = new CustomerService (); @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useValue : singleton }) customerService : CustomerService ; } class Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useClass : CustomerService }) customerService : CustomerService ; // is same as @CreateProvider ( CustomerService ) customerService : CustomerService ; // or even shorter @CreateProvider () customerService : CustomerService ; } Shared Providers \u00b6 Shared providers are singletons, created once at bootstrap time and visible to all application modules! Shared provider is just a normal provider which is included in shared providers list at @RootModule metadata definition. You can read more about modules in modules section . import { RootModule , AwesomeService } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { } @RootModule ({ providers : [], shared_providers : [ AwesomeService ] }) export class ApplicationModule { }","title":"Providers"},{"location":"documentation/rest/providers/#providers","text":"Dependencies are services or objects that a class needs to perform its function.x Providers are a fundamental concept in Typeix Dependency Injection, Typeix uses @typeix/di package which is delivered and exported directly with @typeix/resty package. Providers are basically classes decorated with @Injectable() decorator which are used by DI system to create those objects on application bootstrap or on request instance, basically you need to define @Controller() provider if you want that your provider is created at request level. All other @Module() providers are created at application bootstrap! There are three type of providers class, value and factory provider, functions inside providers array are converted to class providers. There are three types of providers in total: {provde, useClass} is a class provider. {provde, useFactory} is a factory provider. {provde, useValue} is a value provider. Dependent providers?: Array<Function | IProvider> inside of provider (class and factory) are extra dependencies that are created before provider and delivered as dependencies to provider itself. interface IProvider { provide : any ; useValue? : any ; useClass? : Function ; useFactory? : Function ; providers? : Array < Function | IProvider > ; }","title":"Providers"},{"location":"documentation/rest/providers/#scopes","text":"Resty provides two scopes of providers, providers which are created at bootstrap time or also known as application providers and providers that are created at each request are request providers. Big difference is that application providers are singletons where request provider is created and injected at each controller request!","title":"Scopes"},{"location":"documentation/rest/providers/#application","text":"In code below you can see application scope created services: import { Injectable , Module , Controller , Inject , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () findAll () { return \"This action returns all customers\" ; } } As you can see CustomerService is provided within module providers that means that CustomerService class will be created at application bootstrap time and always provided as singleton object. @Injectable () export class CustomerService { @Inject () dataStore : DataStore ; findAll () { return this . dataStore . query ( \"SELECT * FROM Customers\" ); } } @Module ({ controllers : [ CustomerController ], providers : [ CustomerService ] }) export class ApplicationModule { }","title":"Application"},{"location":"documentation/rest/providers/#request","text":"However it's possible to create request scoped providers by simply providing them as controller providers. All request scope providers are memory safe, that means that those objects are automatically cleaned up when response body is sent to client! So in that case you don't need to take care if you actually are pushing some data inside service context as long as they are not referenced to some live objects everything is automatically garbage collected. import { Injectable , Module , Controller , Inject , GET } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" , providers : [ CustomerService ] }) export class CustomerController { @Inject () customerService : CustomerService ; @GET () findAll () { return \"This action returns all customers\" ; } } @Module ({ controllers : [ CustomerController ] }) export class ApplicationModule {}","title":"Request"},{"location":"documentation/rest/providers/#injection-points","text":"Once your provider is created by dependency injection system you can use @Inject() decorator to deliver your object instance to arbitrary provider.","title":"Injection Points"},{"location":"documentation/rest/providers/#property-injection","text":"@Inject(token: Type) decorator is used to inject dependency at property injection point. If you provide token type, DI will ignore type of property, so in example below we can se that @Inject(CustomerService) will actually inject CustomerService for iCustomerService property, all injected properties are created on object context, they are not created on prototype of object! Prototype holds only metadata information! @Inject() customerService: CustomerService; typeix di will inject correct type as long as property is actual object type and not an interface! import { Controller , Inject } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { @Inject () customerService : CustomerService ; @Inject ( CustomerService ) iCustomerService : InterfaceCustomerService ; }","title":"Property Injection"},{"location":"documentation/rest/providers/#parameter-injection","text":"All parameter injections are method scoped, and only visible to actual method! Keep in mind that property injection points are delivered at object creation where parameters are delivered to method at actual method invocation. import { Controller } from \"@typeix/resty\" ; @Controller ({ path : \"/customers\" }) export class CustomerController { indexAction ( @Inject () customerService : CustomerService ) { } }","title":"Parameter Injection"},{"location":"documentation/rest/providers/#create-provider","text":"If you want that your provider is created at creation time, you can use @CreateProvider(Function | IProvider) decorator to automatically create provider for you inside of Service, Controller, Module or Interceptor! It works with all three provider types! import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider () customerService : CustomerService ; } Factory Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useFactory : ( a , b ) => { return new CustomerService ( a , b ); }, providers : [ ProviderA , ProviderB ] }) customerService : CustomerService ; } Value Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; const singleton = new CustomerService (); @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useValue : singleton }) customerService : CustomerService ; } class Provider import { CreateProvider , Injectable } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { @CreateProvider ({ provide : CustomerService , useClass : CustomerService }) customerService : CustomerService ; // is same as @CreateProvider ( CustomerService ) customerService : CustomerService ; // or even shorter @CreateProvider () customerService : CustomerService ; }","title":"Create Provider"},{"location":"documentation/rest/providers/#shared-providers","text":"Shared providers are singletons, created once at bootstrap time and visible to all application modules! Shared provider is just a normal provider which is included in shared providers list at @RootModule metadata definition. You can read more about modules in modules section . import { RootModule , AwesomeService } from \"@typeix/resty\" ; @Injectable () export class AwesomeService { } @RootModule ({ providers : [], shared_providers : [ AwesomeService ] }) export class ApplicationModule { }","title":"Shared Providers"},{"location":"documentation/rest/quick-start/","text":"Resty \u00b6 Build REST Apis with Typeix Resty, REST stands for Representational State Transfer, is an architectural style for designing networked applications. It was introduced by Roy Fielding in his doctoral dissertation in 2000 and has since become a widely adopted approach for building APIs(Application Programming Interfaces) on the internet. Key characteristics of REST include: Statelessness : In REST, each request from a client to a server must contain all the information needed to understand and process the request. This means that the server does not store any information about the client's state between requests. Client-Server Architecture : REST separates the concerns of the client and the server. The client is responsible for the user interface and user experience, while the server is responsible for processing and storing data. Uniform Interface : RESTful APIs provide a standardized way for clients to interact with resources. This includes the use of well-defined endpoints (URIs), standard methods (GET, POST, PUT, DELETE), and consistent data formats (usually JSON or XML). Resource-Based : Resources are the core entities that a RESTful API deals with. These can be anything from users and articles to products and orders. Each resource is uniquely identified by a URI. Stateless Communication : Communication between the client and server is stateless, meaning that each request from the client to the server must contain all the information needed to understand and process the request. Stateless Responses : Responses from the server to the client do not contain any information about the client's state. Instead, they provide information about the current state of the requested resource. Stateless Operations : RESTful APIs utilize standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources. These methods correspond to basic CRUD (Create, Read, Update, Delete) operations. RESTful APIs have become the standard for building web services due to their simplicity, scalability, and compatibility with the HTTP protocol. They are widely used in web and mobile applications to enable communication between clients and servers over the internet. However, it's important to note that while REST provides guidelines, there is room for interpretation and variation in its implementation. Quick Start \u00b6 $ npm i -g @typeix/cli $ typeix new project-name $ cd project-name $ typeix start --watch The project directory will be created, node modules and a few other boilerplate files will be installed, and a src/ directory will be created and populated with several core files. src L app.controller.spec.ts L app.controller.ts L app.module.ts L app.service.ts L bootstrap.ts File Description app.controller.spec.ts The unit tests for the controller. app.controller.ts A basic controller with a single route. app.module.ts The root module of the application. app.service.ts A basic service with a single method. bootstrap.ts Application Server Config File","title":"Quick Start"},{"location":"documentation/rest/quick-start/#resty","text":"Build REST Apis with Typeix Resty, REST stands for Representational State Transfer, is an architectural style for designing networked applications. It was introduced by Roy Fielding in his doctoral dissertation in 2000 and has since become a widely adopted approach for building APIs(Application Programming Interfaces) on the internet. Key characteristics of REST include: Statelessness : In REST, each request from a client to a server must contain all the information needed to understand and process the request. This means that the server does not store any information about the client's state between requests. Client-Server Architecture : REST separates the concerns of the client and the server. The client is responsible for the user interface and user experience, while the server is responsible for processing and storing data. Uniform Interface : RESTful APIs provide a standardized way for clients to interact with resources. This includes the use of well-defined endpoints (URIs), standard methods (GET, POST, PUT, DELETE), and consistent data formats (usually JSON or XML). Resource-Based : Resources are the core entities that a RESTful API deals with. These can be anything from users and articles to products and orders. Each resource is uniquely identified by a URI. Stateless Communication : Communication between the client and server is stateless, meaning that each request from the client to the server must contain all the information needed to understand and process the request. Stateless Responses : Responses from the server to the client do not contain any information about the client's state. Instead, they provide information about the current state of the requested resource. Stateless Operations : RESTful APIs utilize standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources. These methods correspond to basic CRUD (Create, Read, Update, Delete) operations. RESTful APIs have become the standard for building web services due to their simplicity, scalability, and compatibility with the HTTP protocol. They are widely used in web and mobile applications to enable communication between clients and servers over the internet. However, it's important to note that while REST provides guidelines, there is room for interpretation and variation in its implementation.","title":"Resty"},{"location":"documentation/rest/quick-start/#quick-start","text":"$ npm i -g @typeix/cli $ typeix new project-name $ cd project-name $ typeix start --watch The project directory will be created, node modules and a few other boilerplate files will be installed, and a src/ directory will be created and populated with several core files. src L app.controller.spec.ts L app.controller.ts L app.module.ts L app.service.ts L bootstrap.ts File Description app.controller.spec.ts The unit tests for the controller. app.controller.ts A basic controller with a single route. app.module.ts The root module of the application. app.service.ts A basic service with a single method. bootstrap.ts Application Server Config File","title":"Quick Start"},{"location":"documentation/rest/testing/","text":"Testing \u00b6 Automated software testing revolutionizes the way we ensure the quality and reliability of software applications. It involves the use of specialized tools and scripts to execute test cases, compare actual outcomes with expected results, and report any discrepancies. By automating repetitive and time-consuming testing tasks, this approach not only accelerates the testing process but also enhances accuracy, allowing for more comprehensive coverage. In this introduction, we will delve into the fundamental concepts of automated software testing, its benefits, key methodologies, and its pivotal role in modern software development lifecycles. Whether you are a seasoned software engineer or new to the field, understanding the principles of automated testing is essential for building robust and error-free applications in today's dynamic software landscape. Here are key types of automated software testing: Unit testing is the foundation of this process, focused on scrutinizing individual components or units of code in isolation. By subjecting these units to a battery of tests, developers can swiftly identify and rectify defects, laying a solid foundation for robust and error-free software. Contract testing , meanwhile, concentrates on the interactions between different components or services within a system. It verifies that these interactions adhere to predefined contracts, ensuring seamless integration and compatibility. Integration testing takes a broader view, examining how various modules or services function together as an integrated system. It identifies any potential issues that may arise when these units interact, assuring the smooth operation of the integrated components. Stress testing and load testing evaluate the performance of an application under extreme conditions. Stress testing assesses how the application behaves when subjected to near-breaking point conditions, while load testing measures its response to high levels of concurrent user activity. Both are crucial in determining an application's scalability and robustness. End-to-end testing provides a comprehensive evaluation of the entire application, simulating real-world user scenarios to ensure all components work seamlessly together. It validates the application's functionality, performance, and user experience from start to finish. Typeix strives to promote best practices and include effective testing, typeix uses jest as default testing framework!","title":"Unit Testing"},{"location":"documentation/rest/testing/#testing","text":"Automated software testing revolutionizes the way we ensure the quality and reliability of software applications. It involves the use of specialized tools and scripts to execute test cases, compare actual outcomes with expected results, and report any discrepancies. By automating repetitive and time-consuming testing tasks, this approach not only accelerates the testing process but also enhances accuracy, allowing for more comprehensive coverage. In this introduction, we will delve into the fundamental concepts of automated software testing, its benefits, key methodologies, and its pivotal role in modern software development lifecycles. Whether you are a seasoned software engineer or new to the field, understanding the principles of automated testing is essential for building robust and error-free applications in today's dynamic software landscape. Here are key types of automated software testing: Unit testing is the foundation of this process, focused on scrutinizing individual components or units of code in isolation. By subjecting these units to a battery of tests, developers can swiftly identify and rectify defects, laying a solid foundation for robust and error-free software. Contract testing , meanwhile, concentrates on the interactions between different components or services within a system. It verifies that these interactions adhere to predefined contracts, ensuring seamless integration and compatibility. Integration testing takes a broader view, examining how various modules or services function together as an integrated system. It identifies any potential issues that may arise when these units interact, assuring the smooth operation of the integrated components. Stress testing and load testing evaluate the performance of an application under extreme conditions. Stress testing assesses how the application behaves when subjected to near-breaking point conditions, while load testing measures its response to high levels of concurrent user activity. Both are crucial in determining an application's scalability and robustness. End-to-end testing provides a comprehensive evaluation of the entire application, simulating real-world user scenarios to ensure all components work seamlessly together. It validates the application's functionality, performance, and user experience from start to finish. Typeix strives to promote best practices and include effective testing, typeix uses jest as default testing framework!","title":"Testing"},{"location":"documentation/rest/testing/integration/","text":"Integration testing \u00b6 Unlike unit testing, which focuses on individual modules and classes, end-to-end testing covers the interaction of classes and modules. In the following example we will write a test which starts fake server and will execute GET / route and compare results which is actually sent to client! import { Injector , fakeHttpServer } from \"@typeix/resty\" ; import { HomeController } from \"@app/controllers/home.controller\" ; import { TemplateEngine } from \"@app/components/templating-engine.service\" ; import { ApplicationModule } from \"@app/application.module\" ; describe ( \"Home controller\" , () => { let fakeServer ; beforeEach ( async () => { fakeServer = await fakeHttpServer ( ApplicationModule ); }); test ( \"GET /\" , async () => { const injector = Injector . createAndResolve ( TemplateEngine , []); const templateEngine = injector . get ( TemplateEngine ); const body = await templateEngine . compileAndRender ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); const result = fakeServer . GET ( \"/\" ); expect ( result . getBody (). toString ()). toEqual ( body . toString ()); }); }); As you can see there is no extra magic except using dependency injection or Injector to create instance of templating engine and fakeServer to bootstrap application and execute GET / route.","title":"Integration"},{"location":"documentation/rest/testing/integration/#integration-testing","text":"Unlike unit testing, which focuses on individual modules and classes, end-to-end testing covers the interaction of classes and modules. In the following example we will write a test which starts fake server and will execute GET / route and compare results which is actually sent to client! import { Injector , fakeHttpServer } from \"@typeix/resty\" ; import { HomeController } from \"@app/controllers/home.controller\" ; import { TemplateEngine } from \"@app/components/templating-engine.service\" ; import { ApplicationModule } from \"@app/application.module\" ; describe ( \"Home controller\" , () => { let fakeServer ; beforeEach ( async () => { fakeServer = await fakeHttpServer ( ApplicationModule ); }); test ( \"GET /\" , async () => { const injector = Injector . createAndResolve ( TemplateEngine , []); const templateEngine = injector . get ( TemplateEngine ); const body = await templateEngine . compileAndRender ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); const result = fakeServer . GET ( \"/\" ); expect ( result . getBody (). toString ()). toEqual ( body . toString ()); }); }); As you can see there is no extra magic except using dependency injection or Injector to create instance of templating engine and fakeServer to bootstrap application and execute GET / route.","title":"Integration testing"},{"location":"documentation/rest/testing/unit/","text":"Unit testing \u00b6 What is unit testing ? It's a writen code that has a purpose to validate every single unit of application software that actually preforms as designed. Let's take a look resty controller code: @Controller ({ path : \"/\" }) export class HomeController { @Inject () engine : TemplateEngine ; @GET () async actionIndex () : Promise < Buffer > { return await this . engine . compileAndRender ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); } } In the following example we will write a test for actionIndex in HomeController : import { Injector } from \"@typeix/resty\" ; import { HomeController } from \"@app/controllers/home.controller\" ; import { TemplateEngine } from \"@app/components/templating-engine.service\" ; describe ( \"Home controller\" , () => { it ( \"Should test index action\" , async () => { let templateMock = { compileAndRender : () => {} }; const injector = Injector . createAndResolve ( HomeController , [ { provide : TemplateEngine , useValue : templateMock } ]); const controller = injector . get ( HomeController ); const templateSpy = jest . spyOn ( templateMock , \"compileAndRender\" ); await controller . actionIndex (); expect ( templateSpy ). toHaveBeenCalledWith ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); }); }); In example, you can see that we actually ignore result because we are testing single unit actionIndex and it's behavior!","title":"Unit"},{"location":"documentation/rest/testing/unit/#unit-testing","text":"What is unit testing ? It's a writen code that has a purpose to validate every single unit of application software that actually preforms as designed. Let's take a look resty controller code: @Controller ({ path : \"/\" }) export class HomeController { @Inject () engine : TemplateEngine ; @GET () async actionIndex () : Promise < Buffer > { return await this . engine . compileAndRender ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); } } In the following example we will write a test for actionIndex in HomeController : import { Injector } from \"@typeix/resty\" ; import { HomeController } from \"@app/controllers/home.controller\" ; import { TemplateEngine } from \"@app/components/templating-engine.service\" ; describe ( \"Home controller\" , () => { it ( \"Should test index action\" , async () => { let templateMock = { compileAndRender : () => {} }; const injector = Injector . createAndResolve ( HomeController , [ { provide : TemplateEngine , useValue : templateMock } ]); const controller = injector . get ( HomeController ); const templateSpy = jest . spyOn ( templateMock , \"compileAndRender\" ); await controller . actionIndex (); expect ( templateSpy ). toHaveBeenCalledWith ( \"home_id\" , { id : \"NO_ID\" , name : \"this is home page\" , title : \"Home page example\" }); }); }); In example, you can see that we actually ignore result because we are testing single unit actionIndex and it's behavior!","title":"Unit testing"},{"location":"documentation/typeorm/mongodb/","text":"Mongodb \u00b6 MongoDB is a popular, open-source, NoSQL (non-relational) database management system designed to handle large volumes of unstructured or semi-structured data. Developed by MongoDB Inc., it falls under the category of document-oriented databases. Unlike traditional relational databases, which organize data into tables with predefined schemas, MongoDB stores data in flexible, JSON-like documents. This allows for dynamic and schema-less data modeling, making it well-suited for applications where data structures can evolve over time. One of MongoDB's key strengths lies in its ability to scale horizontally, which means it can distribute data across multiple servers to handle high traffic and large datasets. It also supports features like replication for high availability and sharding for even greater scalability. MongoDB is widely used across various industries, including web applications, mobile apps, IoT (Internet of Things) devices, and more. Its flexibility, scalability, and ease of use have made it a popular choice for developers seeking to work with large and rapidly evolving datasets. TypeORM has basic MongoDB support, find out more by reading official docs . Resty framework fully supports integration with typeorm without any extra library or adapter. You can find full example in resty starters repository . Installing \u00b6 Let's start by creating new typeix project, by running @typeix/cli commands: typeix new api-typeorm-mongodb cd api-typeorm-mongodb Install typeorm and postgres connector by running: npm i --save typeorm mongodb You need to install docker for your local development environment and start postgres in docker container docker run -p 27017 :27017 -d --name typeorm-mongo mongo Module \u00b6 In following example let's encapsulate typeorm in datastore module by running: typeix generate mdl DataStore cd src/data-store Goal is to generate following structure L src L orm-config.json L data-store L mongo.module.ts L config L mongo.config.ts L entity L user.entity.ts L repository L user.repository.ts Connection \u00b6 Connection options is a connection configuration you pass to createConnection or define in ormconfig file. Different databases have their own specific mongodb connection options . Inside source let's create orm-config.json file with following configuration: { \"type\" : \"mongodb\" , \"host\" : \"localhost\" , \"port\" : 27017 , \"username\" : null , \"password\" : null , \"database\" : \"typeix\" , \"useUnifiedTopology\" : true , \"useNewUrlParser\" : true , \"synchronize\" : false , \"entities\" : [ \"dist/modules/data-store/entity/**/*.js\" ] } Inside datastore module let's create connection config file: import { CreateProvider , Injectable } from \"@typeix/resty\" ; import { DataSource , DataSourceOptions , MongoEntityManager } from \"\" ; import * as pgConfig from \"~/orm-config.json\" ; import { EntityTarget } from \"typeorm/common/EntityTarget\" ; import { MongoRepository } from \"typeorm/repository/MongoRepository\" ; @Injectable () export class MongoDataSource { @CreateProvider ({ provide : DataSource , useFactory : async () => { return await new DataSource ( < DataSourceOptions > { ... pgConfig , name : \"default\" , logging : process.env.NODE_ENV !== \"prod\" }). initialize (); }, providers : [] }) private dataSource : DataSource ; getDataSource () : DataSource { return this . dataSource ; } getEntityManager () : MongoEntityManager { return this . dataSource . mongoManager ; } getMongoRepository < T > ( entity : EntityTarget < T > ) : MongoRepository < T > { return this . dataSource . getMongoRepository ( entity ); } } Entity \u00b6 Entity is a class that maps to a database table (or collection when using MongoDB). Entity is your model decorated by an @Entity decorator, a database table will be created for such models. You can load/insert/update/remove and perform other operations with them. To add database columns, you simply need to decorate an entity's properties you want to make into a column with a @Column decorator. Let's create our first User Entity: import { Column , Entity , ObjectIdColumn , ObjectID } from \"typeorm\" ; @Entity () export class User { @ObjectIdColumn () id : ObjectID ; @Column () firstName : string ; @Column () lastName : string ; @Column () age : number ; } MongoRepository as Service \u00b6 Repository is just like EntityManager but its operations are limited to a concrete entity. In following example you can see implementation of UserRepository in Service import { Inject , Injectable } from \"@typeix/resty\" ; import { User } from \"~/modules/data-store/entity/user.entity\" ; import { MongoDataSource } from \"~/modules/data-store/configs/mongo-data-source.service\" ; import { MongoRepository } from \"typeorm/repository/MongoRepository\" ; @Injectable () export class UserService { @Inject () mongoDataSource : MongoDataSource ; async find () : Promise < Array < User >> { return this . getRepository (). find (); } async save ( entity : User ) : Promise < User > { return this . getRepository (). save ( entity ); } getRepository () : MongoRepository < User > { return this . mongoDataSource . getMongoRepository ( User ); } } In service we implement custom business logic or extend repository, each repository contains default logic /** * Repository used to manage mongodb documents of a single entity type. */ export declare class MongoRepository < Entity extends ObjectLiteral > extends Repository < Entity > { /** * Entity Manager used by this repository. */ readonly manager : MongoEntityManager ; /** * Raw SQL query execution is not supported by MongoDB. * Calling this method will return an error. */ query ( query : string , parameters? : any []) : Promise < any > ; /** * Using Query Builder with MongoDB is not supported yet. * Calling this method will return an error. */ createQueryBuilder ( alias : string , queryRunner? : QueryRunner ) : SelectQueryBuilder < Entity > ; /** * Finds entities that match given find options or conditions. */ find ( options? : MongoFindManyOptions < Entity > ) : Promise < Entity [] > ; /** * Finds entities that match given find options or conditions. */ findBy ( where : any ) : Promise < Entity [] > ; /** * Finds entities that match given find options or conditions. * Also counts all entities that match given conditions, * but ignores pagination settings (from and take options). */ findAndCount ( options? : MongoFindManyOptions < Entity > ) : Promise < [ Entity [], number ] > ; /** * Finds entities that match given find options or conditions. * Also counts all entities that match given conditions, * but ignores pagination settings (from and take options). */ findAndCountBy ( where : any ) : Promise < [ Entity [], number ] > ; /** * Finds entities by ids. * Optionally find options can be applied. * * @deprecated use `findBy` method instead in conjunction with `In` operator, for example: * * .findBy({ * id: In([1, 2, 3]) * }) */ findByIds ( ids : any [], options? : any ) : Promise < Entity [] > ; /** * Finds first entity that matches given find options. */ findOne ( options : MongoFindOneOptions < Entity > ) : Promise < Entity | null > ; /** * Finds first entity that matches given WHERE conditions. */ findOneBy ( where : any ) : Promise < Entity | null > ; /** * Finds entity that matches given id. * * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example: * * .findOneBy({ * id: 1 // where \"id\" is your primary column name * }) */ findOneById ( id : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID []) : Promise < Entity | null > ; /** * Finds first entity by a given find options. * If entity was not found in the database - rejects with error. */ findOneOrFail ( options : FindOneOptions < Entity > ) : Promise < Entity > ; /** * Finds first entity that matches given where condition. * If entity was not found in the database - rejects with error. */ findOneByOrFail ( where : any ) : Promise < Entity > ; /** * Creates a cursor for a query that can be used to iterate over results from MongoDB. */ createCursor < T = any > ( query? : ObjectLiteral ) : Cursor < T > ; /** * Creates a cursor for a query that can be used to iterate over results from MongoDB. * This returns modified version of cursor that transforms each result into Entity model. */ createEntityCursor ( query? : ObjectLiteral ) : Cursor < Entity > ; /** * Execute an aggregation framework pipeline against the collection. */ aggregate < R = any > ( pipeline : ObjectLiteral [], options? : CollectionAggregationOptions ) : AggregationCursor < R > ; /** * Execute an aggregation framework pipeline against the collection. * This returns modified version of cursor that transforms each result into Entity model. */ aggregateEntity ( pipeline : ObjectLiteral [], options? : CollectionAggregationOptions ) : AggregationCursor < Entity > ; /** * Perform a bulkWrite operation without a fluent API. */ bulkWrite ( operations : ObjectLiteral [], options? : CollectionBulkWriteOptions ) : Promise < BulkWriteOpResultObject > ; /** * Count number of matching documents in the db to a query. */ count ( query? : ObjectLiteral , options? : MongoCountPreferences ) : Promise < number > ; /** * Count number of matching documents in the db to a query. */ countBy ( query? : ObjectLiteral , options? : MongoCountPreferences ) : Promise < number > ; /** * Creates an index on the db and collection. */ createCollectionIndex ( fieldOrSpec : string | any , options? : MongodbIndexOptions ) : Promise < string > ; /** * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher. * Earlier version of MongoDB will throw a command not supported error. * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/. */ createCollectionIndexes ( indexSpecs : ObjectLiteral []) : Promise < void > ; /** * Delete multiple documents on MongoDB. */ deleteMany ( query : ObjectLiteral , options? : CollectionOptions ) : Promise < DeleteWriteOpResultObject > ; /** * Delete a document on MongoDB. */ deleteOne ( query : ObjectLiteral , options? : CollectionOptions ) : Promise < DeleteWriteOpResultObject > ; /** * The distinct command returns returns a list of distinct values for the given key across a collection. */ distinct ( key : string , query : ObjectLiteral , options ?: { readPreference? : ReadPreference | string ; }) : Promise < any > ; /** * Drops an index from this collection. */ dropCollectionIndex ( indexName : string , options? : CollectionOptions ) : Promise < any > ; /** * Drops all indexes from the collection. */ dropCollectionIndexes () : Promise < any > ; /** * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndDelete ( query : ObjectLiteral , options ?: { projection? : Object ; sort? : Object ; maxTimeMS? : number ; }) : Promise < FindAndModifyWriteOpResultObject > ; /** * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndReplace ( query : ObjectLiteral , replacement : Object , options? : FindOneAndReplaceOption ) : Promise < FindAndModifyWriteOpResultObject > ; /** * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndUpdate ( query : ObjectLiteral , update : Object , options? : FindOneAndReplaceOption ) : Promise < FindAndModifyWriteOpResultObject > ; /** * Execute a geo search using a geo haystack index on a collection. */ geoHaystackSearch ( x : number , y : number , options? : GeoHaystackSearchOptions ) : Promise < any > ; /** * Execute the geoNear command to search for items in the collection. */ geoNear ( x : number , y : number , options? : GeoNearOptions ) : Promise < any > ; /** * Run a group command across a collection. */ group ( keys : Object | Array < any > | Function | Code , condition : Object , initial : Object , reduce : Function | Code , finalize : Function | Code , command : boolean , options ?: { readPreference? : ReadPreference | string ; }) : Promise < any > ; /** * Retrieve all the indexes on the collection. */ collectionIndexes () : Promise < any > ; /** * Retrieve all the indexes on the collection. */ collectionIndexExists ( indexes : string | string []) : Promise < boolean > ; /** * Retrieves this collections index info. */ collectionIndexInformation ( options ?: { full : boolean ; }) : Promise < any > ; /** * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types. */ initializeOrderedBulkOp ( options? : CollectionOptions ) : OrderedBulkOperation ; /** * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */ initializeUnorderedBulkOp ( options? : CollectionOptions ) : UnorderedBulkOperation ; /** * Inserts an array of documents into MongoDB. */ insertMany ( docs : ObjectLiteral [], options? : CollectionInsertManyOptions ) : Promise < InsertWriteOpResult > ; /** * Inserts a single document into MongoDB. */ insertOne ( doc : ObjectLiteral , options? : CollectionInsertOneOptions ) : Promise < InsertOneWriteOpResult > ; /** * Returns if the collection is a capped collection. */ isCapped () : Promise < any > ; /** * Get the list of all indexes information for the collection. */ listCollectionIndexes ( options ?: { batchSize? : number ; readPreference? : ReadPreference | string ; }) : CommandCursor ; /** * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection. */ mapReduce ( map : Function | string , reduce : Function | string , options? : MapReduceOptions ) : Promise < any > ; /** * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. * There are no ordering guarantees for returned results. */ parallelCollectionScan ( options? : ParallelCollectionScanOptions ) : Promise < Cursor < Entity > [] > ; /** * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections. */ reIndex () : Promise < any > ; /** * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections. */ rename ( newName : string , options ?: { dropTarget? : boolean ; }) : Promise < Collection < any >> ; /** * Replace a document on MongoDB. */ replaceOne ( query : ObjectLiteral , doc : ObjectLiteral , options? : ReplaceOneOptions ) : Promise < UpdateWriteOpResult > ; /** * Get all the collection statistics. */ stats ( options ?: { scale : number ; }) : Promise < CollStats > ; /** * Update multiple documents on MongoDB. */ updateMany ( query : ObjectLiteral , update : ObjectLiteral , options ?: { upsert? : boolean ; w? : any ; wtimeout? : number ; j? : boolean ; }) : Promise < UpdateWriteOpResult > ; updateOne ( query : ObjectLiteral , update : ObjectLiteral , options? : ReplaceOneOptions ) : Promise < UpdateWriteOpResult > ; }","title":"Mongodb"},{"location":"documentation/typeorm/mongodb/#mongodb","text":"MongoDB is a popular, open-source, NoSQL (non-relational) database management system designed to handle large volumes of unstructured or semi-structured data. Developed by MongoDB Inc., it falls under the category of document-oriented databases. Unlike traditional relational databases, which organize data into tables with predefined schemas, MongoDB stores data in flexible, JSON-like documents. This allows for dynamic and schema-less data modeling, making it well-suited for applications where data structures can evolve over time. One of MongoDB's key strengths lies in its ability to scale horizontally, which means it can distribute data across multiple servers to handle high traffic and large datasets. It also supports features like replication for high availability and sharding for even greater scalability. MongoDB is widely used across various industries, including web applications, mobile apps, IoT (Internet of Things) devices, and more. Its flexibility, scalability, and ease of use have made it a popular choice for developers seeking to work with large and rapidly evolving datasets. TypeORM has basic MongoDB support, find out more by reading official docs . Resty framework fully supports integration with typeorm without any extra library or adapter. You can find full example in resty starters repository .","title":"Mongodb"},{"location":"documentation/typeorm/mongodb/#installing","text":"Let's start by creating new typeix project, by running @typeix/cli commands: typeix new api-typeorm-mongodb cd api-typeorm-mongodb Install typeorm and postgres connector by running: npm i --save typeorm mongodb You need to install docker for your local development environment and start postgres in docker container docker run -p 27017 :27017 -d --name typeorm-mongo mongo","title":"Installing"},{"location":"documentation/typeorm/mongodb/#module","text":"In following example let's encapsulate typeorm in datastore module by running: typeix generate mdl DataStore cd src/data-store Goal is to generate following structure L src L orm-config.json L data-store L mongo.module.ts L config L mongo.config.ts L entity L user.entity.ts L repository L user.repository.ts","title":"Module"},{"location":"documentation/typeorm/mongodb/#connection","text":"Connection options is a connection configuration you pass to createConnection or define in ormconfig file. Different databases have their own specific mongodb connection options . Inside source let's create orm-config.json file with following configuration: { \"type\" : \"mongodb\" , \"host\" : \"localhost\" , \"port\" : 27017 , \"username\" : null , \"password\" : null , \"database\" : \"typeix\" , \"useUnifiedTopology\" : true , \"useNewUrlParser\" : true , \"synchronize\" : false , \"entities\" : [ \"dist/modules/data-store/entity/**/*.js\" ] } Inside datastore module let's create connection config file: import { CreateProvider , Injectable } from \"@typeix/resty\" ; import { DataSource , DataSourceOptions , MongoEntityManager } from \"\" ; import * as pgConfig from \"~/orm-config.json\" ; import { EntityTarget } from \"typeorm/common/EntityTarget\" ; import { MongoRepository } from \"typeorm/repository/MongoRepository\" ; @Injectable () export class MongoDataSource { @CreateProvider ({ provide : DataSource , useFactory : async () => { return await new DataSource ( < DataSourceOptions > { ... pgConfig , name : \"default\" , logging : process.env.NODE_ENV !== \"prod\" }). initialize (); }, providers : [] }) private dataSource : DataSource ; getDataSource () : DataSource { return this . dataSource ; } getEntityManager () : MongoEntityManager { return this . dataSource . mongoManager ; } getMongoRepository < T > ( entity : EntityTarget < T > ) : MongoRepository < T > { return this . dataSource . getMongoRepository ( entity ); } }","title":"Connection"},{"location":"documentation/typeorm/mongodb/#entity","text":"Entity is a class that maps to a database table (or collection when using MongoDB). Entity is your model decorated by an @Entity decorator, a database table will be created for such models. You can load/insert/update/remove and perform other operations with them. To add database columns, you simply need to decorate an entity's properties you want to make into a column with a @Column decorator. Let's create our first User Entity: import { Column , Entity , ObjectIdColumn , ObjectID } from \"typeorm\" ; @Entity () export class User { @ObjectIdColumn () id : ObjectID ; @Column () firstName : string ; @Column () lastName : string ; @Column () age : number ; }","title":"Entity"},{"location":"documentation/typeorm/mongodb/#mongorepository-as-service","text":"Repository is just like EntityManager but its operations are limited to a concrete entity. In following example you can see implementation of UserRepository in Service import { Inject , Injectable } from \"@typeix/resty\" ; import { User } from \"~/modules/data-store/entity/user.entity\" ; import { MongoDataSource } from \"~/modules/data-store/configs/mongo-data-source.service\" ; import { MongoRepository } from \"typeorm/repository/MongoRepository\" ; @Injectable () export class UserService { @Inject () mongoDataSource : MongoDataSource ; async find () : Promise < Array < User >> { return this . getRepository (). find (); } async save ( entity : User ) : Promise < User > { return this . getRepository (). save ( entity ); } getRepository () : MongoRepository < User > { return this . mongoDataSource . getMongoRepository ( User ); } } In service we implement custom business logic or extend repository, each repository contains default logic /** * Repository used to manage mongodb documents of a single entity type. */ export declare class MongoRepository < Entity extends ObjectLiteral > extends Repository < Entity > { /** * Entity Manager used by this repository. */ readonly manager : MongoEntityManager ; /** * Raw SQL query execution is not supported by MongoDB. * Calling this method will return an error. */ query ( query : string , parameters? : any []) : Promise < any > ; /** * Using Query Builder with MongoDB is not supported yet. * Calling this method will return an error. */ createQueryBuilder ( alias : string , queryRunner? : QueryRunner ) : SelectQueryBuilder < Entity > ; /** * Finds entities that match given find options or conditions. */ find ( options? : MongoFindManyOptions < Entity > ) : Promise < Entity [] > ; /** * Finds entities that match given find options or conditions. */ findBy ( where : any ) : Promise < Entity [] > ; /** * Finds entities that match given find options or conditions. * Also counts all entities that match given conditions, * but ignores pagination settings (from and take options). */ findAndCount ( options? : MongoFindManyOptions < Entity > ) : Promise < [ Entity [], number ] > ; /** * Finds entities that match given find options or conditions. * Also counts all entities that match given conditions, * but ignores pagination settings (from and take options). */ findAndCountBy ( where : any ) : Promise < [ Entity [], number ] > ; /** * Finds entities by ids. * Optionally find options can be applied. * * @deprecated use `findBy` method instead in conjunction with `In` operator, for example: * * .findBy({ * id: In([1, 2, 3]) * }) */ findByIds ( ids : any [], options? : any ) : Promise < Entity [] > ; /** * Finds first entity that matches given find options. */ findOne ( options : MongoFindOneOptions < Entity > ) : Promise < Entity | null > ; /** * Finds first entity that matches given WHERE conditions. */ findOneBy ( where : any ) : Promise < Entity | null > ; /** * Finds entity that matches given id. * * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example: * * .findOneBy({ * id: 1 // where \"id\" is your primary column name * }) */ findOneById ( id : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID []) : Promise < Entity | null > ; /** * Finds first entity by a given find options. * If entity was not found in the database - rejects with error. */ findOneOrFail ( options : FindOneOptions < Entity > ) : Promise < Entity > ; /** * Finds first entity that matches given where condition. * If entity was not found in the database - rejects with error. */ findOneByOrFail ( where : any ) : Promise < Entity > ; /** * Creates a cursor for a query that can be used to iterate over results from MongoDB. */ createCursor < T = any > ( query? : ObjectLiteral ) : Cursor < T > ; /** * Creates a cursor for a query that can be used to iterate over results from MongoDB. * This returns modified version of cursor that transforms each result into Entity model. */ createEntityCursor ( query? : ObjectLiteral ) : Cursor < Entity > ; /** * Execute an aggregation framework pipeline against the collection. */ aggregate < R = any > ( pipeline : ObjectLiteral [], options? : CollectionAggregationOptions ) : AggregationCursor < R > ; /** * Execute an aggregation framework pipeline against the collection. * This returns modified version of cursor that transforms each result into Entity model. */ aggregateEntity ( pipeline : ObjectLiteral [], options? : CollectionAggregationOptions ) : AggregationCursor < Entity > ; /** * Perform a bulkWrite operation without a fluent API. */ bulkWrite ( operations : ObjectLiteral [], options? : CollectionBulkWriteOptions ) : Promise < BulkWriteOpResultObject > ; /** * Count number of matching documents in the db to a query. */ count ( query? : ObjectLiteral , options? : MongoCountPreferences ) : Promise < number > ; /** * Count number of matching documents in the db to a query. */ countBy ( query? : ObjectLiteral , options? : MongoCountPreferences ) : Promise < number > ; /** * Creates an index on the db and collection. */ createCollectionIndex ( fieldOrSpec : string | any , options? : MongodbIndexOptions ) : Promise < string > ; /** * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher. * Earlier version of MongoDB will throw a command not supported error. * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/. */ createCollectionIndexes ( indexSpecs : ObjectLiteral []) : Promise < void > ; /** * Delete multiple documents on MongoDB. */ deleteMany ( query : ObjectLiteral , options? : CollectionOptions ) : Promise < DeleteWriteOpResultObject > ; /** * Delete a document on MongoDB. */ deleteOne ( query : ObjectLiteral , options? : CollectionOptions ) : Promise < DeleteWriteOpResultObject > ; /** * The distinct command returns returns a list of distinct values for the given key across a collection. */ distinct ( key : string , query : ObjectLiteral , options ?: { readPreference? : ReadPreference | string ; }) : Promise < any > ; /** * Drops an index from this collection. */ dropCollectionIndex ( indexName : string , options? : CollectionOptions ) : Promise < any > ; /** * Drops all indexes from the collection. */ dropCollectionIndexes () : Promise < any > ; /** * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndDelete ( query : ObjectLiteral , options ?: { projection? : Object ; sort? : Object ; maxTimeMS? : number ; }) : Promise < FindAndModifyWriteOpResultObject > ; /** * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndReplace ( query : ObjectLiteral , replacement : Object , options? : FindOneAndReplaceOption ) : Promise < FindAndModifyWriteOpResultObject > ; /** * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation. */ findOneAndUpdate ( query : ObjectLiteral , update : Object , options? : FindOneAndReplaceOption ) : Promise < FindAndModifyWriteOpResultObject > ; /** * Execute a geo search using a geo haystack index on a collection. */ geoHaystackSearch ( x : number , y : number , options? : GeoHaystackSearchOptions ) : Promise < any > ; /** * Execute the geoNear command to search for items in the collection. */ geoNear ( x : number , y : number , options? : GeoNearOptions ) : Promise < any > ; /** * Run a group command across a collection. */ group ( keys : Object | Array < any > | Function | Code , condition : Object , initial : Object , reduce : Function | Code , finalize : Function | Code , command : boolean , options ?: { readPreference? : ReadPreference | string ; }) : Promise < any > ; /** * Retrieve all the indexes on the collection. */ collectionIndexes () : Promise < any > ; /** * Retrieve all the indexes on the collection. */ collectionIndexExists ( indexes : string | string []) : Promise < boolean > ; /** * Retrieves this collections index info. */ collectionIndexInformation ( options ?: { full : boolean ; }) : Promise < any > ; /** * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types. */ initializeOrderedBulkOp ( options? : CollectionOptions ) : OrderedBulkOperation ; /** * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */ initializeUnorderedBulkOp ( options? : CollectionOptions ) : UnorderedBulkOperation ; /** * Inserts an array of documents into MongoDB. */ insertMany ( docs : ObjectLiteral [], options? : CollectionInsertManyOptions ) : Promise < InsertWriteOpResult > ; /** * Inserts a single document into MongoDB. */ insertOne ( doc : ObjectLiteral , options? : CollectionInsertOneOptions ) : Promise < InsertOneWriteOpResult > ; /** * Returns if the collection is a capped collection. */ isCapped () : Promise < any > ; /** * Get the list of all indexes information for the collection. */ listCollectionIndexes ( options ?: { batchSize? : number ; readPreference? : ReadPreference | string ; }) : CommandCursor ; /** * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection. */ mapReduce ( map : Function | string , reduce : Function | string , options? : MapReduceOptions ) : Promise < any > ; /** * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. * There are no ordering guarantees for returned results. */ parallelCollectionScan ( options? : ParallelCollectionScanOptions ) : Promise < Cursor < Entity > [] > ; /** * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections. */ reIndex () : Promise < any > ; /** * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections. */ rename ( newName : string , options ?: { dropTarget? : boolean ; }) : Promise < Collection < any >> ; /** * Replace a document on MongoDB. */ replaceOne ( query : ObjectLiteral , doc : ObjectLiteral , options? : ReplaceOneOptions ) : Promise < UpdateWriteOpResult > ; /** * Get all the collection statistics. */ stats ( options ?: { scale : number ; }) : Promise < CollStats > ; /** * Update multiple documents on MongoDB. */ updateMany ( query : ObjectLiteral , update : ObjectLiteral , options ?: { upsert? : boolean ; w? : any ; wtimeout? : number ; j? : boolean ; }) : Promise < UpdateWriteOpResult > ; updateOne ( query : ObjectLiteral , update : ObjectLiteral , options? : ReplaceOneOptions ) : Promise < UpdateWriteOpResult > ; }","title":"MongoRepository as Service"},{"location":"documentation/typeorm/rdbms/","text":"Relational Databases (RDBMS) \u00b6 Relational databases are a type of database management system (DBMS) that organize and store data in tables, which are structured collections of rows and columns. They follow the principles of the relational model, as proposed by Edgar Codd in the 1970s. Here are some key characteristics and concepts associated with relational databases: Tables : Data is organized into tables, where each table represents a specific entity or concept. For example, a database for a library might have tables for books, authors, and borrowers. Rows and Columns : Each table consists of rows (also known as records or tuples) and columns (also known as attributes). Rows represent individual instances of data, while columns define the attributes or properties of those instances. Primary Keys : A primary key is a unique identifier for each row in a table. It ensures that every record can be uniquely identified, which is crucial for data integrity. Relationships : Relational databases allow for the establishment of relationships between tables. For example, in a library database, a book can be associated with an author through a relationship. Normalization : This is the process of organizing the data in a database to minimize redundancy and dependency. It helps to maintain data integrity and optimize storage. Structured Query Language (SQL) : SQL is a domain-specific language used to interact with relational databases. It allows users to perform operations like querying, inserting, updating, and deleting data. ACID Properties : Relational databases adhere to ACID properties - Atomicity, Consistency, Isolation, and Durability. These properties ensure that database transactions are reliably processed. Transactions : A transaction is a unit of work that involves one or more operations on the database. It either completes in full or is rolled back entirely in case of an error. Integrity Constraints : These are rules that help maintain data accuracy and consistency. Examples include foreign key constraints, which enforce relationships between tables. Data Integrity : Relational databases are designed to enforce data integrity through various mechanisms like primary keys, foreign keys, and constraints. Relational databases are widely used in various industries and applications, including business management systems, e-commerce platforms, financial systems, and more. Popular examples of relational database management systems (RDBMS) include MySQL, PostgreSQL, Oracle Database, Microsoft SQL Server, and SQLite. They provide a robust framework for organizing, querying, and managing structured data. TypeORM \u00b6 Object\u2013relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems using object-oriented programming languages. TypeORM is an ORM that can run in NodeJS, and can be used with TypeScript. TypeORM provides support for many relational databases: PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. TypeORM supports both Active Record and Data Mapper patterns, unlike all other JavaScript ORMs currently in existence, which means you can write high quality, loosely coupled, scalable, maintainable applications the most productive way. Resty framework fully supports integration with typeorm without any extra library or adapter. You can find full example in resty starters repository . Installing \u00b6 Let's start by creating new typeix project, by running @typeix/cli commands: typeix new api-typeorm-sql cd api-typeorm-sql Install typeorm and postgres connector by running: npm i --save typeorm pg You need to install docker for your local development environment and start postgres in docker container docker run -p 5432 :5432 --name typeorm-pg -e POSTGRES_DB = typeix -e POSTGRES_PASSWORD = admin -e POSTGRES_USER = postgres -d postgres Module \u00b6 In following example let's encapsulate typeorm in datastore module by running: typeix generate mdl DataStore cd src/data-store Goal is to generate following structure L src L orm-config.json L data-store L pg.module.ts L config L pg.config.ts L pg.logger.config.ts L entity L user.entity.ts L repository L user.repository.ts L migration L {timestamp}-users.ts Connection \u00b6 Connection options is a connection configuration you pass to createConnection or define in ormconfig file. Different databases have their own specific connection options . Inside source let's create orm-config.json file with following configuration: { \"type\" : \"postgres\" , \"host\" : \"localhost\" , \"port\" : 5432 , \"username\" : \"postgres\" , \"password\" : \"admin\" , \"database\" : \"typeix\" , \"synchronize\" : false , \"migrationsRun\" : true , \"logging\" : true , \"cli\" : { \"entitiesDir\" : \"src/data-store/entity\" , \"migrationsDir\" : \"src/data-store/migration\" , \"subscribersDir\" : \"src/data-store/subscriber\" }, \"entities\" : [ \"dist/data-store/entity/**/*.js\" ], \"migrations\" : [ \"dist/data-store/migration/**/*.js\" ], \"subscribers\" : [ \"dist/data-store/subscriber/**/*.js\" ] } Inside datastore module let's create connection config file: @Injectable () export class PgDataSource { @CreateProvider ({ provide : DataSource , useFactory : async ( logger : Logger ) => { return await new DataSource ( < DataSourceOptions > { ... pgConfig , name : \"default\" , logging : process.env.NODE_ENV !== \"prod\" , logger }). initialize (); }, providers : [ PgDataSourceLogger , Injector ] }) private dataSource : DataSource ; getDataSource () : DataSource { return this . dataSource ; } getEntityManager () : EntityManager { return this . dataSource . manager ; } getRepository < T > ( entity : EntityTarget < T > ) : Repository < T > { return this . dataSource . manager . getRepository ( entity ); } } Entity \u00b6 Entity is a class that maps to a database table (or collection when using MongoDB). Entity is your model decorated by an @Entity decorator, a database table will be created for such models. You can load/insert/update/remove and perform other operations with them. To add database columns, you simply need to decorate an entity's properties you want to make into a column with a @Column decorator. Let's create our first User Entity: import { Column , Entity , PrimaryGeneratedColumn } from \"\" ; @Entity () export class User { @PrimaryGeneratedColumn () id : number ; @Column () firstName : string ; @Column () lastName : string ; @Column () age : number ; } Repository and Services \u00b6 Repository is just like EntityManager but its operations are limited to a concrete entity. In following example you can see implementation of UserRepository by creating a UserService @Injectable () export class UserService { @Inject () pgDataSource : PgDataSource ; async find () : Promise < Array < User >> { return this . getRepository (). find (); } async save ( entity : User ) : Promise < User > { return this . getRepository (). save ( entity ); } getRepository () : Repository < User > { return this . pgDataSource . getRepository ( User ); } } In service we implement custom business logic or extend repository, each repository contains default logic declare class Repository < Entity extends ObjectLiteral > { get metadata () : import ( \"..\" ). EntityMetadata ; createQueryBuilder ( alias? : string , queryRunner? : QueryRunner ) : SelectQueryBuilder < Entity > ; hasId ( entity : Entity ) : boolean ; getId ( entity : Entity ) : any ; create ( entityLike : DeepPartial < Entity > ) : Entity ; merge ( mergeIntoEntity : Entity , ...entityLikes : DeepPartial < Entity > []) : Entity ; preload ( entityLike : DeepPartial < Entity > ) : Promise < Entity | undefined > ; save < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; remove ( entity : Entity , options? : RemoveOptions ) : Promise < Entity > ; softRemove < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; recover < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; insert ( entity : QueryDeepPartialEntity < Entity > | QueryDeepPartialEntity < Entity > []) : Promise < InsertResult > ; update ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > , partialEntity : QueryDeepPartialEntity < Entity > ) : Promise < UpdateResult > ; upsert ( entityOrEntities : QueryDeepPartialEntity < Entity > | QueryDeepPartialEntity < Entity > [], conflictPathsOrOptions : string [] | UpsertOptions < Entity > ) : Promise < InsertResult > ; delete ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < DeleteResult > ; softDelete ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < UpdateResult > ; restore ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < UpdateResult > ; count ( options? : FindManyOptions < Entity > ) : Promise < number > ; countBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < number > ; find ( options? : FindManyOptions < Entity > ) : Promise < Entity [] > ; findBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity [] > ; findAndCount ( options? : FindManyOptions < Entity > ) : Promise < [ Entity [], number ] > ; findAndCountBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < [ Entity [], number ] > ; findByIds ( ids : any []) : Promise < Entity [] > ; findOne ( options : FindOneOptions < Entity > ) : Promise < Entity | null > ; findOneBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity | null > ; findOneById ( id : number | string | Date | ObjectID ) : Promise < Entity | null > ; findOneOrFail ( options : FindOneOptions < Entity > ) : Promise < Entity > ; findOneByOrFail ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity > ; query ( query : string , parameters? : any []) : Promise < any > ; increment ( conditions : FindOptionsWhere < Entity > , propertyPath : string , value : number | string ) : Promise < UpdateResult > ; decrement ( conditions : FindOptionsWhere < Entity > , propertyPath : string , value : number | string ) : Promise < UpdateResult > ; extend < CustomRepository > ( custom : CustomRepository & ThisType < Repository < Entity > & CustomRepository > ) : Repository < Entity > & CustomRepository ; } Transactions \u00b6 A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. In following example you can see implementation of transactional request interceptor, and we can use it in controller: import { addRequestInterceptor , Inject , Injectable , Injector , InterceptedRequest , RequestInterceptor } from \"@typeix/resty\" ; import { PgDataSource } from \"~/modules/data-store/configs/pgdatasource.config\" ; import { Repository } from \"typeorm\" ; @Injectable () class TransactionalInterceptor implements RequestInterceptor { @Inject () injector : Injector ; @Inject () config : PgDataSource ; async invoke ( request : InterceptedRequest ) : Promise < any > { const queryRunner = this . config . getDataSource (). createQueryRunner (); await queryRunner . connect (); await queryRunner . startTransaction ( \"READ COMMITTED\" ); try { const type = request . args . type ; const repository : Repository < typeof type > = await queryRunner . manager . getRepository ( type ); this . injector . set ( Repository , repository ); await request . handler (); await queryRunner . commitTransaction (); } catch ( err ) { await queryRunner . rollbackTransaction (); } finally { await queryRunner . release (); } } } /** * Transactional * @param type * @constructor */ export function Transactional < T > ( type : T ) { return addRequestInterceptor ( TransactionalInterceptor , { type }); } As we can see below in controller we inject transactional UserRepository which is injected by Transactional Interceptor @Controller ({ path : \"/\" , providers : [], interceptors : [] }) export class AppController { @Inject () appService : AppService ; @POST ( \"users\" ) @Transactional ( User ) createUser ( @Inject () repository : Repository < User > ) { const user = new User (); user . age = 100 ; user . firstName = \"Igor\" ; user . lastName = \"Surname\" ; return repository . save ( user ); } } Subscribers \u00b6 With TypeORM subscribers, you can listen to specific entity events. Migrations \u00b6 Migrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated CLI. { \"scripts\" : { \"migration:run\" : \"typeorm -f src/ormconfig.json migration:run\" , \"migration:create\" : \"typeorm -f src/ormconfig.json migration:create -n\" , } } Logger \u00b6 You can enable logging of all queries and errors by simply setting logging: true in your connection options. You can enable different types of logging in connection options: query - logs all queries. error - logs all failed queries and errors. schema - logs the schema build process. warn - logs internal orm warnings. info - logs internal orm informative messages. log - logs internal orm log messages. If you have performance issues, you can log queries that take too much time to execute by setting maxQueryExecutionTime in connection options. By Creating custom TypeORM logger we can integrate it with Typeix Logger: import { Logger as TypeOrmLogger , QueryRunner } from \"typeorm\" ; import { Inject , Injectable , Logger } from \"@typeix/resty\" ; import * as chalk from \"chalk\" ; const highlight = require ( 'cli-highlight' ). highlight @Injectable () export class PgLoggerConfig implements TypeOrmLogger { @Inject () logger : Logger ; protected getRunnerInfo ( queryRunner? : QueryRunner ) { return queryRunner && queryRunner . data [ \"request\" ] ? \"(\" + queryRunner . data [ \"request\" ]. url + \") \" : \"\" ; } log ( level : \"log\" | \"info\" | \"warn\" , message : any , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); if ( level === \"warn\" ) { this . logger . warn ( info + message ); } else { this . logger . info ( info + message ); } } logMigration ( message : string , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . info ( info + \"Migration: \" + chalk . white ( highlight ( message , { language : 'sql' , ignoreIllegals : true }))); } logQuery ( query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . info ( info + \"Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); } logQueryError ( error : string | Error , query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . error ( info + \"Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); this . logger . error ( error ); } logQuerySlow ( time : number , query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . warn ( info + \"Slow Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); } logSchemaBuild ( message : string , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . warn ( info + \"Schema Build: \" + chalk . white ( highlight ( message , { language : 'sql' , ignoreIllegals : true }))); } }","title":"Relational Database"},{"location":"documentation/typeorm/rdbms/#relational-databases-rdbms","text":"Relational databases are a type of database management system (DBMS) that organize and store data in tables, which are structured collections of rows and columns. They follow the principles of the relational model, as proposed by Edgar Codd in the 1970s. Here are some key characteristics and concepts associated with relational databases: Tables : Data is organized into tables, where each table represents a specific entity or concept. For example, a database for a library might have tables for books, authors, and borrowers. Rows and Columns : Each table consists of rows (also known as records or tuples) and columns (also known as attributes). Rows represent individual instances of data, while columns define the attributes or properties of those instances. Primary Keys : A primary key is a unique identifier for each row in a table. It ensures that every record can be uniquely identified, which is crucial for data integrity. Relationships : Relational databases allow for the establishment of relationships between tables. For example, in a library database, a book can be associated with an author through a relationship. Normalization : This is the process of organizing the data in a database to minimize redundancy and dependency. It helps to maintain data integrity and optimize storage. Structured Query Language (SQL) : SQL is a domain-specific language used to interact with relational databases. It allows users to perform operations like querying, inserting, updating, and deleting data. ACID Properties : Relational databases adhere to ACID properties - Atomicity, Consistency, Isolation, and Durability. These properties ensure that database transactions are reliably processed. Transactions : A transaction is a unit of work that involves one or more operations on the database. It either completes in full or is rolled back entirely in case of an error. Integrity Constraints : These are rules that help maintain data accuracy and consistency. Examples include foreign key constraints, which enforce relationships between tables. Data Integrity : Relational databases are designed to enforce data integrity through various mechanisms like primary keys, foreign keys, and constraints. Relational databases are widely used in various industries and applications, including business management systems, e-commerce platforms, financial systems, and more. Popular examples of relational database management systems (RDBMS) include MySQL, PostgreSQL, Oracle Database, Microsoft SQL Server, and SQLite. They provide a robust framework for organizing, querying, and managing structured data.","title":"Relational Databases (RDBMS)"},{"location":"documentation/typeorm/rdbms/#typeorm","text":"Object\u2013relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems using object-oriented programming languages. TypeORM is an ORM that can run in NodeJS, and can be used with TypeScript. TypeORM provides support for many relational databases: PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. TypeORM supports both Active Record and Data Mapper patterns, unlike all other JavaScript ORMs currently in existence, which means you can write high quality, loosely coupled, scalable, maintainable applications the most productive way. Resty framework fully supports integration with typeorm without any extra library or adapter. You can find full example in resty starters repository .","title":"TypeORM"},{"location":"documentation/typeorm/rdbms/#installing","text":"Let's start by creating new typeix project, by running @typeix/cli commands: typeix new api-typeorm-sql cd api-typeorm-sql Install typeorm and postgres connector by running: npm i --save typeorm pg You need to install docker for your local development environment and start postgres in docker container docker run -p 5432 :5432 --name typeorm-pg -e POSTGRES_DB = typeix -e POSTGRES_PASSWORD = admin -e POSTGRES_USER = postgres -d postgres","title":"Installing"},{"location":"documentation/typeorm/rdbms/#module","text":"In following example let's encapsulate typeorm in datastore module by running: typeix generate mdl DataStore cd src/data-store Goal is to generate following structure L src L orm-config.json L data-store L pg.module.ts L config L pg.config.ts L pg.logger.config.ts L entity L user.entity.ts L repository L user.repository.ts L migration L {timestamp}-users.ts","title":"Module"},{"location":"documentation/typeorm/rdbms/#connection","text":"Connection options is a connection configuration you pass to createConnection or define in ormconfig file. Different databases have their own specific connection options . Inside source let's create orm-config.json file with following configuration: { \"type\" : \"postgres\" , \"host\" : \"localhost\" , \"port\" : 5432 , \"username\" : \"postgres\" , \"password\" : \"admin\" , \"database\" : \"typeix\" , \"synchronize\" : false , \"migrationsRun\" : true , \"logging\" : true , \"cli\" : { \"entitiesDir\" : \"src/data-store/entity\" , \"migrationsDir\" : \"src/data-store/migration\" , \"subscribersDir\" : \"src/data-store/subscriber\" }, \"entities\" : [ \"dist/data-store/entity/**/*.js\" ], \"migrations\" : [ \"dist/data-store/migration/**/*.js\" ], \"subscribers\" : [ \"dist/data-store/subscriber/**/*.js\" ] } Inside datastore module let's create connection config file: @Injectable () export class PgDataSource { @CreateProvider ({ provide : DataSource , useFactory : async ( logger : Logger ) => { return await new DataSource ( < DataSourceOptions > { ... pgConfig , name : \"default\" , logging : process.env.NODE_ENV !== \"prod\" , logger }). initialize (); }, providers : [ PgDataSourceLogger , Injector ] }) private dataSource : DataSource ; getDataSource () : DataSource { return this . dataSource ; } getEntityManager () : EntityManager { return this . dataSource . manager ; } getRepository < T > ( entity : EntityTarget < T > ) : Repository < T > { return this . dataSource . manager . getRepository ( entity ); } }","title":"Connection"},{"location":"documentation/typeorm/rdbms/#entity","text":"Entity is a class that maps to a database table (or collection when using MongoDB). Entity is your model decorated by an @Entity decorator, a database table will be created for such models. You can load/insert/update/remove and perform other operations with them. To add database columns, you simply need to decorate an entity's properties you want to make into a column with a @Column decorator. Let's create our first User Entity: import { Column , Entity , PrimaryGeneratedColumn } from \"\" ; @Entity () export class User { @PrimaryGeneratedColumn () id : number ; @Column () firstName : string ; @Column () lastName : string ; @Column () age : number ; }","title":"Entity"},{"location":"documentation/typeorm/rdbms/#repository-and-services","text":"Repository is just like EntityManager but its operations are limited to a concrete entity. In following example you can see implementation of UserRepository by creating a UserService @Injectable () export class UserService { @Inject () pgDataSource : PgDataSource ; async find () : Promise < Array < User >> { return this . getRepository (). find (); } async save ( entity : User ) : Promise < User > { return this . getRepository (). save ( entity ); } getRepository () : Repository < User > { return this . pgDataSource . getRepository ( User ); } } In service we implement custom business logic or extend repository, each repository contains default logic declare class Repository < Entity extends ObjectLiteral > { get metadata () : import ( \"..\" ). EntityMetadata ; createQueryBuilder ( alias? : string , queryRunner? : QueryRunner ) : SelectQueryBuilder < Entity > ; hasId ( entity : Entity ) : boolean ; getId ( entity : Entity ) : any ; create ( entityLike : DeepPartial < Entity > ) : Entity ; merge ( mergeIntoEntity : Entity , ...entityLikes : DeepPartial < Entity > []) : Entity ; preload ( entityLike : DeepPartial < Entity > ) : Promise < Entity | undefined > ; save < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; remove ( entity : Entity , options? : RemoveOptions ) : Promise < Entity > ; softRemove < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; recover < T extends DeepPartial < Entity >> ( entity : T , options? : SaveOptions ) : Promise < T & Entity > ; insert ( entity : QueryDeepPartialEntity < Entity > | QueryDeepPartialEntity < Entity > []) : Promise < InsertResult > ; update ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > , partialEntity : QueryDeepPartialEntity < Entity > ) : Promise < UpdateResult > ; upsert ( entityOrEntities : QueryDeepPartialEntity < Entity > | QueryDeepPartialEntity < Entity > [], conflictPathsOrOptions : string [] | UpsertOptions < Entity > ) : Promise < InsertResult > ; delete ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < DeleteResult > ; softDelete ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < UpdateResult > ; restore ( criteria : string | string [] | number | number [] | Date | Date [] | ObjectID | ObjectID [] | FindOptionsWhere < Entity > ) : Promise < UpdateResult > ; count ( options? : FindManyOptions < Entity > ) : Promise < number > ; countBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < number > ; find ( options? : FindManyOptions < Entity > ) : Promise < Entity [] > ; findBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity [] > ; findAndCount ( options? : FindManyOptions < Entity > ) : Promise < [ Entity [], number ] > ; findAndCountBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < [ Entity [], number ] > ; findByIds ( ids : any []) : Promise < Entity [] > ; findOne ( options : FindOneOptions < Entity > ) : Promise < Entity | null > ; findOneBy ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity | null > ; findOneById ( id : number | string | Date | ObjectID ) : Promise < Entity | null > ; findOneOrFail ( options : FindOneOptions < Entity > ) : Promise < Entity > ; findOneByOrFail ( where : FindOptionsWhere < Entity > | FindOptionsWhere < Entity > []) : Promise < Entity > ; query ( query : string , parameters? : any []) : Promise < any > ; increment ( conditions : FindOptionsWhere < Entity > , propertyPath : string , value : number | string ) : Promise < UpdateResult > ; decrement ( conditions : FindOptionsWhere < Entity > , propertyPath : string , value : number | string ) : Promise < UpdateResult > ; extend < CustomRepository > ( custom : CustomRepository & ThisType < Repository < Entity > & CustomRepository > ) : Repository < Entity > & CustomRepository ; }","title":"Repository and Services"},{"location":"documentation/typeorm/rdbms/#transactions","text":"A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. In following example you can see implementation of transactional request interceptor, and we can use it in controller: import { addRequestInterceptor , Inject , Injectable , Injector , InterceptedRequest , RequestInterceptor } from \"@typeix/resty\" ; import { PgDataSource } from \"~/modules/data-store/configs/pgdatasource.config\" ; import { Repository } from \"typeorm\" ; @Injectable () class TransactionalInterceptor implements RequestInterceptor { @Inject () injector : Injector ; @Inject () config : PgDataSource ; async invoke ( request : InterceptedRequest ) : Promise < any > { const queryRunner = this . config . getDataSource (). createQueryRunner (); await queryRunner . connect (); await queryRunner . startTransaction ( \"READ COMMITTED\" ); try { const type = request . args . type ; const repository : Repository < typeof type > = await queryRunner . manager . getRepository ( type ); this . injector . set ( Repository , repository ); await request . handler (); await queryRunner . commitTransaction (); } catch ( err ) { await queryRunner . rollbackTransaction (); } finally { await queryRunner . release (); } } } /** * Transactional * @param type * @constructor */ export function Transactional < T > ( type : T ) { return addRequestInterceptor ( TransactionalInterceptor , { type }); } As we can see below in controller we inject transactional UserRepository which is injected by Transactional Interceptor @Controller ({ path : \"/\" , providers : [], interceptors : [] }) export class AppController { @Inject () appService : AppService ; @POST ( \"users\" ) @Transactional ( User ) createUser ( @Inject () repository : Repository < User > ) { const user = new User (); user . age = 100 ; user . firstName = \"Igor\" ; user . lastName = \"Surname\" ; return repository . save ( user ); } }","title":"Transactions"},{"location":"documentation/typeorm/rdbms/#subscribers","text":"With TypeORM subscribers, you can listen to specific entity events.","title":"Subscribers"},{"location":"documentation/typeorm/rdbms/#migrations","text":"Migrations provide a way to incrementally update the database schema to keep it in sync with the application's data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated CLI. { \"scripts\" : { \"migration:run\" : \"typeorm -f src/ormconfig.json migration:run\" , \"migration:create\" : \"typeorm -f src/ormconfig.json migration:create -n\" , } }","title":"Migrations"},{"location":"documentation/typeorm/rdbms/#logger","text":"You can enable logging of all queries and errors by simply setting logging: true in your connection options. You can enable different types of logging in connection options: query - logs all queries. error - logs all failed queries and errors. schema - logs the schema build process. warn - logs internal orm warnings. info - logs internal orm informative messages. log - logs internal orm log messages. If you have performance issues, you can log queries that take too much time to execute by setting maxQueryExecutionTime in connection options. By Creating custom TypeORM logger we can integrate it with Typeix Logger: import { Logger as TypeOrmLogger , QueryRunner } from \"typeorm\" ; import { Inject , Injectable , Logger } from \"@typeix/resty\" ; import * as chalk from \"chalk\" ; const highlight = require ( 'cli-highlight' ). highlight @Injectable () export class PgLoggerConfig implements TypeOrmLogger { @Inject () logger : Logger ; protected getRunnerInfo ( queryRunner? : QueryRunner ) { return queryRunner && queryRunner . data [ \"request\" ] ? \"(\" + queryRunner . data [ \"request\" ]. url + \") \" : \"\" ; } log ( level : \"log\" | \"info\" | \"warn\" , message : any , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); if ( level === \"warn\" ) { this . logger . warn ( info + message ); } else { this . logger . info ( info + message ); } } logMigration ( message : string , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . info ( info + \"Migration: \" + chalk . white ( highlight ( message , { language : 'sql' , ignoreIllegals : true }))); } logQuery ( query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . info ( info + \"Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); } logQueryError ( error : string | Error , query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . error ( info + \"Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); this . logger . error ( error ); } logQuerySlow ( time : number , query : string , parameters? : any [], queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . warn ( info + \"Slow Query: \" + chalk . white ( highlight ( query , { language : 'sql' , ignoreIllegals : true }))); } logSchemaBuild ( message : string , queryRunner? : QueryRunner ) : any { const info = this . getRunnerInfo ( queryRunner ); this . logger . warn ( info + \"Schema Build: \" + chalk . white ( highlight ( message , { language : 'sql' , ignoreIllegals : true }))); } }","title":"Logger"},{"location":"documentation/websockets/socket-io/","text":"","title":"Using socket.io protocol over websockets"},{"location":"documentation/websockets/stomp/","text":"","title":"Using STOMP protocol over websockets"},{"location":"documentation/websockets/websocket/","text":"Websockets \u00b6 WebSockets provide a communication protocol that allows for real-time, bidirectional communication between a client (usually a web browser) and a server over a single, long-lived connection. Unlike traditional HTTP requests, which are stateless and require separate requests for each interaction, WebSockets enable continuous data exchange between the client and server. Key characteristics of WebSockets include: Bi-Directional Communication: WebSockets allow both the client and server to send messages to each other at any time, enabling real-time updates and interactive applications. Persistent Connection: Once established, a WebSocket connection remains open, allowing for efficient and instant data transfer without the overhead of repeatedly establishing new connections. Low Latency: Since WebSockets eliminate the need for repeated request-response cycles, they provide low-latency communication, making them ideal for applications that require rapid updates. Efficient Use of Resources: WebSockets reduce the need for continuous polling or long-polling techniques, which can be resource-intensive for both the client and server. Support for Various Data Formats: WebSockets can transmit data in various formats, including plain text, JSON, XML, and binary data, giving developers flexibility in designing their communication protocols. Cross-Domain Communication: WebSockets can facilitate communication between different domains, provided that the server supports cross-origin resource sharing (CORS) or other necessary security measures. WebSockets find applications in a wide range of real-time or interactive scenarios, such as chat applications, online gaming, collaborative editing tools, financial trading platforms, and live sports updates. It's worth noting that while WebSockets offer significant advantages for real-time communication, they may not be the best choice for all situations. Factors like security considerations, compatibility with existing systems, and the nature of the application's requirements should be taken into account when deciding whether to implement WebSockets. Quick Start \u00b6 Typeix resty websocket implementation is a wrapper over ws node.js package. Resty fully supports integration with ws using @typeix/resty-ws wrapper library. You can find full example in resty starters websockets repository . Installation \u00b6 Start by installing the required packages: $ npm i -g @typeix/cli $ typeix new ws-project $ cd ws-project $ npm i @typeix/resty-ws $ npm i --save-dev @types/ws $ typeix start --watch Controller \u00b6 For each websocket connection typeix create new instance of websocket controller and it's isolated from each other, on each socket connection close controller and it's resources are destroyed. import { IAfterConstruct , Inject , Logger } from \"@typeix/resty\" ; import { Arg , Subscribe , WebSocketController , WebSocket } from \"@typeix/resty-ws\" ; import { IncomingMessage } from \"http\" ; @WebSocketController ({ providers : [], socketOptions : { path : \"/ws\" } }) export class AppControllerSocket implements IAfterConstruct { @Inject () logger : Logger ; @Inject () socket : WebSocket ; @Inject () request : IncomingMessage ; @Subscribe ( \"message\" ) onMessage ( @Arg () buffer : Buffer , @Arg () isBinary : boolean ) { this . logger . debug ({ message : buffer.toString (), isBinary }, \"MESSAGE SENT\" ); this . socket . send ( JSON . stringify ({ message : \"RECEIVED: \" + buffer . toString () })); } afterConstruct () : void { this . logger . info ({ headers : this.request.headers }); } } Decorators \u00b6 Decorator Info @WebSocketController() defines websocket controller, for each socket connection new controller is instantiated and providers defined on controller @Subscribe() subscribe to web socket event \"error\", \"message\", \"open\", \"ping\", \"pong\", \"redirect\", \"upgrade\", \"unexpected-response\" @Arg() inject argument of subscribed event handler each event type has different argument types and number of arguments @Args() inject list of all handler arguments that are you subscribing, each handler type has different number of arguments Socket Events \u00b6 Event types that you can subscribe to with @Subscribe() decorator and arguments that you can inject, all injectables from Injector will work as well. Message \u00b6 Emitted when a message is received. data is the message content. isBinary specifies whether the message is binary or not. @Subscribe ( \"message\" ) onMessage ( @Inject () serviceD : MyCustomServiceD , @Arg () buffer : Buffer , @Arg () isBinary : boolean ) Close \u00b6 Emitted when the connection is closed. code is a numeric value indicating the status code explaining why the connection has been closed. reason is a Buffer containing a human-readable string explaining why the connection has been closed. @Subscribe ( \"close\" ) onClose ( @Arg () code : number , @Inject () serviceA : MyCustomService , @Arg () reason : Buffer ) Error \u00b6 Emitted when an error occurs @Subscribe ( \"error\" ) onError ( @Arg () err : Error ) Errors may have a .code property, matching one of the string values defined below under Error codes. Error Code Info WS_ERR_EXPECTED_FIN A WebSocket frame was received with the FIN bit not set when it was expected. WS_ERR_EXPECTED_MASK An unmasked WebSocket frame was received by a WebSocket server. WS_ERR_INVALID_CLOSE_CODE A WebSocket close frame was received with an invalid close code. WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH A control frame with an invalid payload length was received. WS_ERR_INVALID_OPCODE A WebSocket frame was received with an invalid opcode. WS_ERR_INVALID_UTF8 A text or close frame was received containing invalid UTF-8 data. WS_ERR_UNEXPECTED_MASK A masked WebSocket frame was received by a WebSocket client. WS_ERR_UNEXPECTED_RSV_1 A WebSocket frame was received with the RSV1 bit set unexpectedly. WS_ERR_UNEXPECTED_RSV_2_3 A WebSocket frame was received with the RSV2 or RSV3 bit set unexpectedly. WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH A data frame was received with a length longer than the max supported length (2^53 - 1, due to JavaScript language limitations). WS_ERR_UNSUPPORTED_MESSAGE_LENGTH A message was received with a length longer than the maximum supported length, as configured by the maxPayload option. Upgrade \u00b6 Emitted when response headers are received from the server as part of the handshake. This allows you to read headers from the server, for example 'set-cookie' headers @Subscribe ( \"upgrade\" ) onUpgrade ( @Arg () request : IncomingMessage ) Open \u00b6 Emitted when the connection is established @Subscribe ( \"open\" ) onOpen () Ping \u00b6 Emitted when a ping is received @Subscribe ( \"ping\" ) onPing ( @Arg () buffer : Buffer ) Pong \u00b6 Emitted when a pong is received @Subscribe ( \"pong\" ) onPong ( @Arg () buffer : Buffer ) Unexpected Response \u00b6 Emitted when the server response is not the expected one, for example a 401 response. This event gives the ability to read the response in order to extract useful information. If the server sends an invalid response and there isn't a listener for this event, an error is emitted @Subscribe ( \"unexpected-response\" ) onUnexpectedResponse ( @Arg () request : ClientRequest , @Arg () response : IncomingMessage ) Testing \u00b6 You can fully do integration test for your implementation of sockets. import { createServer , IncomingMessage } from \"http\" ; describe ( \"WebSocket\" , () => { it ( \"Integration test\" , async () => { @RootModule ({ shared_providers : [], controllers : [ AppControllerSocket ] }) class WebSocketApplication { } const server = createServer (); await pipeWebSocket ( server , WebSocketApplication ); await pipeServer ( server , WebSocketApplication ); return await new Promise (( resolve ) => { server . listen ( 0 , () => { const address : AddressInfo = < AddressInfo > server . address (); const ws = new WebSocket ( \"ws://localhost:\" + address . port + \"/ws\" , { headers : { Authorization : \"Basic \" + Buffer . from ( \"admin:admin\" ). toString ( \"base64\" ) } }); ws . on ( \"open\" , () => ws . send ( message )); ws . on ( \"message\" , data => messages . push ( data . toString ())); setTimeout (() => { expect ( messages ). toContain ( message ); ws . terminate (); server . close (); resolve ( true ); }, 1000 ); }); }); }); });","title":"Quick Start"},{"location":"documentation/websockets/websocket/#websockets","text":"WebSockets provide a communication protocol that allows for real-time, bidirectional communication between a client (usually a web browser) and a server over a single, long-lived connection. Unlike traditional HTTP requests, which are stateless and require separate requests for each interaction, WebSockets enable continuous data exchange between the client and server. Key characteristics of WebSockets include: Bi-Directional Communication: WebSockets allow both the client and server to send messages to each other at any time, enabling real-time updates and interactive applications. Persistent Connection: Once established, a WebSocket connection remains open, allowing for efficient and instant data transfer without the overhead of repeatedly establishing new connections. Low Latency: Since WebSockets eliminate the need for repeated request-response cycles, they provide low-latency communication, making them ideal for applications that require rapid updates. Efficient Use of Resources: WebSockets reduce the need for continuous polling or long-polling techniques, which can be resource-intensive for both the client and server. Support for Various Data Formats: WebSockets can transmit data in various formats, including plain text, JSON, XML, and binary data, giving developers flexibility in designing their communication protocols. Cross-Domain Communication: WebSockets can facilitate communication between different domains, provided that the server supports cross-origin resource sharing (CORS) or other necessary security measures. WebSockets find applications in a wide range of real-time or interactive scenarios, such as chat applications, online gaming, collaborative editing tools, financial trading platforms, and live sports updates. It's worth noting that while WebSockets offer significant advantages for real-time communication, they may not be the best choice for all situations. Factors like security considerations, compatibility with existing systems, and the nature of the application's requirements should be taken into account when deciding whether to implement WebSockets.","title":"Websockets"},{"location":"documentation/websockets/websocket/#quick-start","text":"Typeix resty websocket implementation is a wrapper over ws node.js package. Resty fully supports integration with ws using @typeix/resty-ws wrapper library. You can find full example in resty starters websockets repository .","title":"Quick Start"},{"location":"documentation/websockets/websocket/#installation","text":"Start by installing the required packages: $ npm i -g @typeix/cli $ typeix new ws-project $ cd ws-project $ npm i @typeix/resty-ws $ npm i --save-dev @types/ws $ typeix start --watch","title":"Installation"},{"location":"documentation/websockets/websocket/#controller","text":"For each websocket connection typeix create new instance of websocket controller and it's isolated from each other, on each socket connection close controller and it's resources are destroyed. import { IAfterConstruct , Inject , Logger } from \"@typeix/resty\" ; import { Arg , Subscribe , WebSocketController , WebSocket } from \"@typeix/resty-ws\" ; import { IncomingMessage } from \"http\" ; @WebSocketController ({ providers : [], socketOptions : { path : \"/ws\" } }) export class AppControllerSocket implements IAfterConstruct { @Inject () logger : Logger ; @Inject () socket : WebSocket ; @Inject () request : IncomingMessage ; @Subscribe ( \"message\" ) onMessage ( @Arg () buffer : Buffer , @Arg () isBinary : boolean ) { this . logger . debug ({ message : buffer.toString (), isBinary }, \"MESSAGE SENT\" ); this . socket . send ( JSON . stringify ({ message : \"RECEIVED: \" + buffer . toString () })); } afterConstruct () : void { this . logger . info ({ headers : this.request.headers }); } }","title":"Controller"},{"location":"documentation/websockets/websocket/#decorators","text":"Decorator Info @WebSocketController() defines websocket controller, for each socket connection new controller is instantiated and providers defined on controller @Subscribe() subscribe to web socket event \"error\", \"message\", \"open\", \"ping\", \"pong\", \"redirect\", \"upgrade\", \"unexpected-response\" @Arg() inject argument of subscribed event handler each event type has different argument types and number of arguments @Args() inject list of all handler arguments that are you subscribing, each handler type has different number of arguments","title":"Decorators"},{"location":"documentation/websockets/websocket/#socket-events","text":"Event types that you can subscribe to with @Subscribe() decorator and arguments that you can inject, all injectables from Injector will work as well.","title":"Socket Events"},{"location":"documentation/websockets/websocket/#message","text":"Emitted when a message is received. data is the message content. isBinary specifies whether the message is binary or not. @Subscribe ( \"message\" ) onMessage ( @Inject () serviceD : MyCustomServiceD , @Arg () buffer : Buffer , @Arg () isBinary : boolean )","title":"Message"},{"location":"documentation/websockets/websocket/#close","text":"Emitted when the connection is closed. code is a numeric value indicating the status code explaining why the connection has been closed. reason is a Buffer containing a human-readable string explaining why the connection has been closed. @Subscribe ( \"close\" ) onClose ( @Arg () code : number , @Inject () serviceA : MyCustomService , @Arg () reason : Buffer )","title":"Close"},{"location":"documentation/websockets/websocket/#error","text":"Emitted when an error occurs @Subscribe ( \"error\" ) onError ( @Arg () err : Error ) Errors may have a .code property, matching one of the string values defined below under Error codes. Error Code Info WS_ERR_EXPECTED_FIN A WebSocket frame was received with the FIN bit not set when it was expected. WS_ERR_EXPECTED_MASK An unmasked WebSocket frame was received by a WebSocket server. WS_ERR_INVALID_CLOSE_CODE A WebSocket close frame was received with an invalid close code. WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH A control frame with an invalid payload length was received. WS_ERR_INVALID_OPCODE A WebSocket frame was received with an invalid opcode. WS_ERR_INVALID_UTF8 A text or close frame was received containing invalid UTF-8 data. WS_ERR_UNEXPECTED_MASK A masked WebSocket frame was received by a WebSocket client. WS_ERR_UNEXPECTED_RSV_1 A WebSocket frame was received with the RSV1 bit set unexpectedly. WS_ERR_UNEXPECTED_RSV_2_3 A WebSocket frame was received with the RSV2 or RSV3 bit set unexpectedly. WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH A data frame was received with a length longer than the max supported length (2^53 - 1, due to JavaScript language limitations). WS_ERR_UNSUPPORTED_MESSAGE_LENGTH A message was received with a length longer than the maximum supported length, as configured by the maxPayload option.","title":"Error"},{"location":"documentation/websockets/websocket/#upgrade","text":"Emitted when response headers are received from the server as part of the handshake. This allows you to read headers from the server, for example 'set-cookie' headers @Subscribe ( \"upgrade\" ) onUpgrade ( @Arg () request : IncomingMessage )","title":"Upgrade"},{"location":"documentation/websockets/websocket/#open","text":"Emitted when the connection is established @Subscribe ( \"open\" ) onOpen ()","title":"Open"},{"location":"documentation/websockets/websocket/#ping","text":"Emitted when a ping is received @Subscribe ( \"ping\" ) onPing ( @Arg () buffer : Buffer )","title":"Ping"},{"location":"documentation/websockets/websocket/#pong","text":"Emitted when a pong is received @Subscribe ( \"pong\" ) onPong ( @Arg () buffer : Buffer )","title":"Pong"},{"location":"documentation/websockets/websocket/#unexpected-response","text":"Emitted when the server response is not the expected one, for example a 401 response. This event gives the ability to read the response in order to extract useful information. If the server sends an invalid response and there isn't a listener for this event, an error is emitted @Subscribe ( \"unexpected-response\" ) onUnexpectedResponse ( @Arg () request : ClientRequest , @Arg () response : IncomingMessage )","title":"Unexpected Response"},{"location":"documentation/websockets/websocket/#testing","text":"You can fully do integration test for your implementation of sockets. import { createServer , IncomingMessage } from \"http\" ; describe ( \"WebSocket\" , () => { it ( \"Integration test\" , async () => { @RootModule ({ shared_providers : [], controllers : [ AppControllerSocket ] }) class WebSocketApplication { } const server = createServer (); await pipeWebSocket ( server , WebSocketApplication ); await pipeServer ( server , WebSocketApplication ); return await new Promise (( resolve ) => { server . listen ( 0 , () => { const address : AddressInfo = < AddressInfo > server . address (); const ws = new WebSocket ( \"ws://localhost:\" + address . port + \"/ws\" , { headers : { Authorization : \"Basic \" + Buffer . from ( \"admin:admin\" ). toString ( \"base64\" ) } }); ws . on ( \"open\" , () => ws . send ( message )); ws . on ( \"message\" , data => messages . push ( data . toString ())); setTimeout (() => { expect ( messages ). toContain ( message ); ws . terminate (); server . close (); resolve ( true ); }, 1000 ); }); }); }); });","title":"Testing"},{"location":"packages/di/","text":"Dependency Injection \u00b6 Dependency Injection (DI) is a design pattern used to implement IoC. Learn more about dependency injector in fundamentals section . You can use DI lib in any of your projects. Installing \u00b6 npm i @typeix/di --save Injector API \u00b6 All providers are immutable, however you can define mutable provider keys. If provider is not mutable, and you are trying to create new instance of same provider on current Injector instance, injector will throw error. Injector.getProviders(provider: IProvider, propertyKey?: string) will return all providers which needs to be injected, if propertyKey is not defined injector will return providers for constructor. Injector.getAllMetadataForTarget(provider: IProvider) will return all metadata, injector cache them internally. Works with class provider only. import { Injectable , Injector , Inject } from \"@typeix/di\" ; Injector . createAndResolve ( ServiceA , [ ServiceB ]). then ( injector => { let service = injector . get ( ServiceA ); return service . getName (); }); Async API: class Injector { constructor ( _parent? : Injector , keys? : Array < any > ); static getProviders ( provider : IProvider , propertyKey? : string ) : Array < IProvider > ; // returns all metadata for provider static getAllMetadataForTarget ( provider : IProvider ) : Array < IMetadata > ; // creates new child injector, provider and providers static createAndResolveChild ( parent : Injector , Class : MixedProvider , providers : Array < MixedProvider > ) : Promise < Injector > ; // creates new injector, provider and providers+- static createAndResolve ( Class : MixedProvider , providers : Array < MixedProvider > ) : Promise < Injector > ; // creates new provider and providers createAndResolve ( provider : IProvider , providers : Array < IProvider > ) : Promise < any > ; // clens current injectables and all child injectors & providers destroy () : void ; // check if providier exists on current Injector instance has ( key : any ) : boolean ; // get provider value from current Injector if not found bubble parrent's // if not found on any of parents exception is thrown. get ( provider : string , Class? : IProvider ) : any ; get < T > ( provider : Type < T > , Class? : IProvider ) : T ; // set provider and value set ( key : any , value : Object ) : void ; getParent () : Injector ; setParent ( injector : Injector ) : void ; setName ( provider : IProvider ) : void ; hasChild ( injector : Injector ) : boolean ; addChild ( injector : Injector ) : this ; } Sync Injector API \u00b6 Since version 8.x default Injector behavior is converted to async API, if you want to use sync api you need to use Injector.Sync.createAndResolve or Injector.Sync.createAndResolveChild difference is that Async API supports Async providers, it's allowed to use of async/await in factory and return Promises in value provider! import { Injectable , Injector , Inject } from \"@typeix/di\" ; let injector = Injector . Sync . createAndResolve ( ServiceA , [ ServiceB ]); let service = injector . get ( ServiceA ); service . getName (); Sync API: class SyncInjector { constructor ( _parent? : Injector , keys? : Array < any > ); static getProviders ( provider : IProvider , propertyKey? : string ) : Array < IProvider > ; // returns all metadata for provider static getAllMetadataForTarget ( provider : IProvider ) : Array < IMetadata > ; // creates new child injector, provider and providers static createAndResolveChild ( parent : Injector , Class : Function | IProvider , providers : Array < MixedProvider > ) : Injector ; // creates new injector, provider and providers static createAndResolve ( Class : Function | IProvider , providers : Array < MixedProvider > ) : Injector ; // creates new provider and providers createAndResolve ( provider : IProvider , providers : Array < IProvider > ) : any ; // clens current injectables and all child injectors & providers destroy () : void ; // check if providier exists on current SyncInjector instance has ( key : any ) : boolean ; // get provider value from current SyncInjector if not found bubble parrent's // if not found on any of parents exception is thrown. get ( provider : string , Class? : IProvider ) : any ; get < T > ( provider : Type < T > , Class? : IProvider ) : T ; // set provider and value set ( key : any , value : Object ) : void ; getParent () : Injector ; setParent ( injector : Injector ) : void ; setName ( provider : IProvider ) : void ; hasChild ( injector : Injector ) : boolean ; addChild ( injector : Injector ) : this ; }","title":"@typeix/di"},{"location":"packages/di/#dependency-injection","text":"Dependency Injection (DI) is a design pattern used to implement IoC. Learn more about dependency injector in fundamentals section . You can use DI lib in any of your projects.","title":"Dependency Injection"},{"location":"packages/di/#installing","text":"npm i @typeix/di --save","title":"Installing"},{"location":"packages/di/#injector-api","text":"All providers are immutable, however you can define mutable provider keys. If provider is not mutable, and you are trying to create new instance of same provider on current Injector instance, injector will throw error. Injector.getProviders(provider: IProvider, propertyKey?: string) will return all providers which needs to be injected, if propertyKey is not defined injector will return providers for constructor. Injector.getAllMetadataForTarget(provider: IProvider) will return all metadata, injector cache them internally. Works with class provider only. import { Injectable , Injector , Inject } from \"@typeix/di\" ; Injector . createAndResolve ( ServiceA , [ ServiceB ]). then ( injector => { let service = injector . get ( ServiceA ); return service . getName (); }); Async API: class Injector { constructor ( _parent? : Injector , keys? : Array < any > ); static getProviders ( provider : IProvider , propertyKey? : string ) : Array < IProvider > ; // returns all metadata for provider static getAllMetadataForTarget ( provider : IProvider ) : Array < IMetadata > ; // creates new child injector, provider and providers static createAndResolveChild ( parent : Injector , Class : MixedProvider , providers : Array < MixedProvider > ) : Promise < Injector > ; // creates new injector, provider and providers+- static createAndResolve ( Class : MixedProvider , providers : Array < MixedProvider > ) : Promise < Injector > ; // creates new provider and providers createAndResolve ( provider : IProvider , providers : Array < IProvider > ) : Promise < any > ; // clens current injectables and all child injectors & providers destroy () : void ; // check if providier exists on current Injector instance has ( key : any ) : boolean ; // get provider value from current Injector if not found bubble parrent's // if not found on any of parents exception is thrown. get ( provider : string , Class? : IProvider ) : any ; get < T > ( provider : Type < T > , Class? : IProvider ) : T ; // set provider and value set ( key : any , value : Object ) : void ; getParent () : Injector ; setParent ( injector : Injector ) : void ; setName ( provider : IProvider ) : void ; hasChild ( injector : Injector ) : boolean ; addChild ( injector : Injector ) : this ; }","title":"Injector API"},{"location":"packages/di/#sync-injector-api","text":"Since version 8.x default Injector behavior is converted to async API, if you want to use sync api you need to use Injector.Sync.createAndResolve or Injector.Sync.createAndResolveChild difference is that Async API supports Async providers, it's allowed to use of async/await in factory and return Promises in value provider! import { Injectable , Injector , Inject } from \"@typeix/di\" ; let injector = Injector . Sync . createAndResolve ( ServiceA , [ ServiceB ]); let service = injector . get ( ServiceA ); service . getName (); Sync API: class SyncInjector { constructor ( _parent? : Injector , keys? : Array < any > ); static getProviders ( provider : IProvider , propertyKey? : string ) : Array < IProvider > ; // returns all metadata for provider static getAllMetadataForTarget ( provider : IProvider ) : Array < IMetadata > ; // creates new child injector, provider and providers static createAndResolveChild ( parent : Injector , Class : Function | IProvider , providers : Array < MixedProvider > ) : Injector ; // creates new injector, provider and providers static createAndResolve ( Class : Function | IProvider , providers : Array < MixedProvider > ) : Injector ; // creates new provider and providers createAndResolve ( provider : IProvider , providers : Array < IProvider > ) : any ; // clens current injectables and all child injectors & providers destroy () : void ; // check if providier exists on current SyncInjector instance has ( key : any ) : boolean ; // get provider value from current SyncInjector if not found bubble parrent's // if not found on any of parents exception is thrown. get ( provider : string , Class? : IProvider ) : any ; get < T > ( provider : Type < T > , Class? : IProvider ) : T ; // set provider and value set ( key : any , value : Object ) : void ; getParent () : Injector ; setParent ( injector : Injector ) : void ; setName ( provider : IProvider ) : void ; hasChild ( injector : Injector ) : boolean ; addChild ( injector : Injector ) : this ; }","title":"Sync Injector API"},{"location":"packages/logger/","text":"Logger \u00b6 Resty comes with a built-in Pino logger wrapper which is used during application bootstrapping such as displaying scanned routing info (i.e., system logging, bootstrap errors). You can fully control the behavior of the logging system: disable logging entirely specify the log level of detail (e.g., display errors, warnings, debug information, etc.) customize the default logger by extending it create your own custom implementation, to log your own application-level events and messages. For more advanced logging functionality, you can make use of any Node.js logging package, such as Winston , to implement a completely custom, production grade logging system. Usage \u00b6 interface LoggerOptions { options : pino.LoggerOptions ; stream? : pino.DestinationStream ; } const options : LoggerOptions = { options : { level : \"error\" } }; const logger = new Logger ( options ); logger . info ({ id : 1 , whatever : 2 }, \"Some nice custom message\" );","title":"@typeix/logger"},{"location":"packages/logger/#logger","text":"Resty comes with a built-in Pino logger wrapper which is used during application bootstrapping such as displaying scanned routing info (i.e., system logging, bootstrap errors). You can fully control the behavior of the logging system: disable logging entirely specify the log level of detail (e.g., display errors, warnings, debug information, etc.) customize the default logger by extending it create your own custom implementation, to log your own application-level events and messages. For more advanced logging functionality, you can make use of any Node.js logging package, such as Winston , to implement a completely custom, production grade logging system.","title":"Logger"},{"location":"packages/logger/#usage","text":"interface LoggerOptions { options : pino.LoggerOptions ; stream? : pino.DestinationStream ; } const options : LoggerOptions = { options : { level : \"error\" } }; const logger = new Logger ( options ); logger . info ({ id : 1 , whatever : 2 }, \"Some nice custom message\" );","title":"Usage"},{"location":"packages/metadata/","text":"Metadata \u00b6 With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript. Installing \u00b6 npm i @typeix/metadata --save Creating Decorators \u00b6 Defining custom decorators has not been easier, API will take care that metadataKeys are created correctly and passed to low level metadata api. import { createClassDecorator , createParameterDecorator , createPropertyDecorator , createParameterAndPropertyDecorator , createMethodDecorator } from \"@typeix/metadata\" ; const Injectable = () => createClassDecorator ( Injectable ); const Inject = ( token ? ) => createParameterAndPropertyDecorator ( Inject , { token }); const Produces = ( type ) => createMethodDecorator ( Produces , { type }); const Render = ( type ) => createMethodDecorator ( Produces , { type }); const PathParam = ( value ) => createParameterDecorator ( Produces , { value }); @Injectable () class AService { } @Injectable () class BService { } @Injectable () class RootController { @Inject () aService : AService ; @Inject () bService : BService ; @Produces ( \"application/json\" ) actionIndex ( @Inject () first : AService , @Inject () second : BService ) { } } @Injectable () class HomeController extends RootController { @Render ( \"home\" ) actionHome ( @Inject () first : AService , @Inject ( BService ) second : BService , @PathParam ( \"name\" ) name : string ) { } } const metadata : Array < IMetadata > = getAllMetadataForTarget ( HomeController ); Interface IMetadata \u00b6 args - are custom arguments passed by decorator metadataKey - is unique decorator key auto generated by metadata api type - class, method, property, parameter decoratorType - (above type) + mixed is createParameterAndPropertyDecorator decorator - actual reference to decorator Function propertyKey - user defined method name or constructor paramIndex - it's defined if decorator is parameter type designType - value from design:type typescript metadata designParam - values from design:paramtypes typescript metadata designReturn - values from design:returntype typescript metadata export interface IMetadata { args : any ; metadataKey : string ; type ? : string ; decoratorType? : string ; decorator? : Function ; propertyKey? : string | symbol ; paramIndex? : number ; designType? : any ; designParam? : any ; designReturn? : any ; } All metadata for target can be requested via getAllMetadataForTarget function, which returns list of metadata. eg.: [ { args : { token : BService }, decoratorType : \"mixed\" , decorator : Inject , type : \"parameter\" , metadataKey : `@typeix:parameter:Inject:1: ${ getDecoratorUUID ( Inject ) } ` , paramIndex : 1 , propertyKey : \"actionHome\" , designParam : [ AService , BService , String ] } ... ]","title":"@typeix/metadata"},{"location":"packages/metadata/#metadata","text":"With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript.","title":"Metadata"},{"location":"packages/metadata/#installing","text":"npm i @typeix/metadata --save","title":"Installing"},{"location":"packages/metadata/#creating-decorators","text":"Defining custom decorators has not been easier, API will take care that metadataKeys are created correctly and passed to low level metadata api. import { createClassDecorator , createParameterDecorator , createPropertyDecorator , createParameterAndPropertyDecorator , createMethodDecorator } from \"@typeix/metadata\" ; const Injectable = () => createClassDecorator ( Injectable ); const Inject = ( token ? ) => createParameterAndPropertyDecorator ( Inject , { token }); const Produces = ( type ) => createMethodDecorator ( Produces , { type }); const Render = ( type ) => createMethodDecorator ( Produces , { type }); const PathParam = ( value ) => createParameterDecorator ( Produces , { value }); @Injectable () class AService { } @Injectable () class BService { } @Injectable () class RootController { @Inject () aService : AService ; @Inject () bService : BService ; @Produces ( \"application/json\" ) actionIndex ( @Inject () first : AService , @Inject () second : BService ) { } } @Injectable () class HomeController extends RootController { @Render ( \"home\" ) actionHome ( @Inject () first : AService , @Inject ( BService ) second : BService , @PathParam ( \"name\" ) name : string ) { } } const metadata : Array < IMetadata > = getAllMetadataForTarget ( HomeController );","title":"Creating Decorators"},{"location":"packages/metadata/#interface-imetadata","text":"args - are custom arguments passed by decorator metadataKey - is unique decorator key auto generated by metadata api type - class, method, property, parameter decoratorType - (above type) + mixed is createParameterAndPropertyDecorator decorator - actual reference to decorator Function propertyKey - user defined method name or constructor paramIndex - it's defined if decorator is parameter type designType - value from design:type typescript metadata designParam - values from design:paramtypes typescript metadata designReturn - values from design:returntype typescript metadata export interface IMetadata { args : any ; metadataKey : string ; type ? : string ; decoratorType? : string ; decorator? : Function ; propertyKey? : string | symbol ; paramIndex? : number ; designType? : any ; designParam? : any ; designReturn? : any ; } All metadata for target can be requested via getAllMetadataForTarget function, which returns list of metadata. eg.: [ { args : { token : BService }, decoratorType : \"mixed\" , decorator : Inject , type : \"parameter\" , metadataKey : `@typeix:parameter:Inject:1: ${ getDecoratorUUID ( Inject ) } ` , paramIndex : 1 , propertyKey : \"actionHome\" , designParam : [ AService , BService , String ] } ... ]","title":"Interface IMetadata"},{"location":"packages/modules/","text":"Modules \u00b6 Package provides Modules API with Dependency Injection, A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata information to ModuleInjector, that makes use of to organize application module dependency graph. Injector uses deep-tree left traversal algorithm to create application module instances, that means that deepest three objects are created first. Objects would be created in order A -> C -> E -> D -> B -> H -> I -> G -> F if we illustrate that would look like: A H / \\ | C E I \\ / | D G | / B / \\ / F You can easily extend application module decorator to provide custom metadata API in own projects, due to large application graph application modules should be initialized once on application start or bootstrap time. Installing: npm i @typeix/modules @typeix/di --save npm i @types/node typescript --save-dev Decorators \u00b6 @Module() decorator contains metadata information of import modules, export providers and providers to be created. imports - can only contain modules or module imports exports - providers to be exported which are created or imported at module creation providers - list of providers that are created at module creation export interface IModuleMetadata { imports? : Array < Function | IProvider > ; exports? : Array < Function | IProvider > ; providers : Array < Function | IProvider > ; } Extending module decorator in custom projects can be done as following: import { Module as AModule , IModuleMetadata as AIModuleMetadata } from \"@typeix/modules\" ; export interface IModuleMetadata extends AIModuleMetadata { controllers? : Array < Function | IProvider > ; path? : string ; } export function Module ( config : IModuleMetadata ) : ClassDecorator { if ( ! isArray ( config . exports )) { config . exports = []; } return AModule ( config ); } Usage \u00b6 Once created modules can be accessed via ModuleInjector, in example we can see that ApplicationModuleD create providers AService and BService and exports them to other modules, what that means is that same object reference will be provided to ApplicationModuleC or module with imports ApplicationModuleD , however ApplicationModuleB will receive same instance of service BService but AService will be newly created object since is defined as provider in providers: [AService] import { Module , ModuleInjector } from \"@typeix/modules\" ; import { Injector , Injectable , Inject } from \"@typeix/di\" ; @Injectable class AService { } @Injectable class BService { @Inject () aService : AService ; doWhatever () {} } @Module ({ providers : [ AService , BService ], exports : [ AService , BService ] }) class ApplicationModuleD { @Inject () bService : BService ; @Inject () aService : AService ; } ApplicationModuleC implements ApplicationModuleD and BService, AService are same references exported from ApplicationModuleD. @Module ({ imports : [ ApplicationModuleD ], exports : [ AService , BService ], providers : [] }) class ApplicationModuleC { @Inject () bService : BService ; @Inject () aService : AService ; } ApplicationModuleB implements ApplicationModuleC and BService is same reference however AService is new instance of AService class, because it's provided as new provider on ApplicationModuleB. @Module ({ imports : [ ApplicationModuleC ], providers : [ AService ] }) class ApplicationModuleB { @Inject () bService : BService ; @Inject () aService : AService ; } ModuleInjector \u00b6 NOTE: By default all providers are immutable, however you can define mutable provider keys. If provider is not mutable, and you are trying to create new instance of same provider on current ModuleInjector instance, injector will throw error. Async \u00b6 Since version 8.x default Injector behavior is converted to async API, if you want to use sync api you need to use ModuleInjector.Sync.createAndResolve difference is that Async API supports Async providers, it's allowed to use of async/await in factory and return Promises in value provider! ModuleInjector.createAndResolve(Class, sharedProviders) special sharedProviders property will create all providers which are provided and visible to all modules, however if module have same provider provided in providers module metadata, new instance will be delivered to that module. class ModuleInjector { static createAndResolve ( Class : Function | IProvider , sharedProviders : Array < Function | IProvider > , mutableKeys? : Array < any > ) : Promise < ModuleInjector > ; get ( Class : Function | IProvider ) : any ; getInjector ( Class : Function | IProvider ) : Injector ; has ( Class : IProvider | Function ) : boolean ; remove ( Class : Function | IProvider ) : boolean ; getAllMetadata () : Map < any , IModuleMetadata > ; createAndResolveSharedProviders ( providers : Array < Function | IProvider > ) : Promise < Injector > ; createAndResolve ( Class : Function | IProvider , mutableKeys? : Array < any > ) : Promise < Injector > ; } Once modules are created by ModuleInjector all objects and references can be accessed via API const injector = await ModuleInjector . createAndResolve ( ApplicationModuleB ); Sync API \u00b6 Sync api is accessible via ModuleInjector.Sync.createAndResolve(Class, sharedProviders) or by simply importing SyncModuleInjector class SyncModuleInjector { static createAndResolve ( Class : Function | IProvider , sharedProviders : Array < Function | IProvider > , mutableKeys? : Array < any > ) : SyncModuleInjector ; get ( Class : Function | IProvider ) : any ; getInjector ( Class : Function | IProvider ) : SyncInjector ; has ( Class : IProvider | Function ) : boolean ; remove ( Class : Function | IProvider ) : boolean ; getAllMetadata () : Map < any , IModuleMetadata > ; createAndResolveSharedProviders ( providers : Array < Function | IProvider > ) : SyncInjector ; createAndResolve ( Class : Function | IProvider , mutableKeys? : Array < any > ) : SyncInjector ; } In following example we can see sync api usage: const injector = ModuleInjector . Sync . createAndResolve ( ApplicationModuleB ); const dModule : ApplicationModuleD = injector . get ( ApplicationModuleD ); const cModule : ApplicationModuleC = injector . get ( ApplicationModuleC ); const bModule : ApplicationModuleB = injector . get ( ApplicationModuleB ); bModule . myAction (); const bModuleInjector = injector . getInjector ( ApplicationModuleB ); const bService = bModuleInjector . get ( BService ); bService . doWhatever (); In example above injected service references are evaluated as true const dModuleInjector = injector . getInjector ( ApplicationModuleD ); const cModuleInjector = injector . getInjector ( ApplicationModuleC ); const bModuleInjector = injector . getInjector ( ApplicationModuleB ); bModuleInjector . get ( BService ) === cModuleInjector . get ( BService ) bModuleInjector . get ( BService ) === dModuleInjector . get ( BService ) cModuleInjector . get ( AService ) === dModuleInjector . get ( AService ) bModuleInjector . get ( AService ) != cModuleInjector . get ( AService ) bModuleInjector . get ( AService ) != dModuleInjector . get ( AService )","title":"@typeix/modules"},{"location":"packages/modules/#modules","text":"Package provides Modules API with Dependency Injection, A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata information to ModuleInjector, that makes use of to organize application module dependency graph. Injector uses deep-tree left traversal algorithm to create application module instances, that means that deepest three objects are created first. Objects would be created in order A -> C -> E -> D -> B -> H -> I -> G -> F if we illustrate that would look like: A H / \\ | C E I \\ / | D G | / B / \\ / F You can easily extend application module decorator to provide custom metadata API in own projects, due to large application graph application modules should be initialized once on application start or bootstrap time. Installing: npm i @typeix/modules @typeix/di --save npm i @types/node typescript --save-dev","title":"Modules"},{"location":"packages/modules/#decorators","text":"@Module() decorator contains metadata information of import modules, export providers and providers to be created. imports - can only contain modules or module imports exports - providers to be exported which are created or imported at module creation providers - list of providers that are created at module creation export interface IModuleMetadata { imports? : Array < Function | IProvider > ; exports? : Array < Function | IProvider > ; providers : Array < Function | IProvider > ; } Extending module decorator in custom projects can be done as following: import { Module as AModule , IModuleMetadata as AIModuleMetadata } from \"@typeix/modules\" ; export interface IModuleMetadata extends AIModuleMetadata { controllers? : Array < Function | IProvider > ; path? : string ; } export function Module ( config : IModuleMetadata ) : ClassDecorator { if ( ! isArray ( config . exports )) { config . exports = []; } return AModule ( config ); }","title":"Decorators"},{"location":"packages/modules/#usage","text":"Once created modules can be accessed via ModuleInjector, in example we can see that ApplicationModuleD create providers AService and BService and exports them to other modules, what that means is that same object reference will be provided to ApplicationModuleC or module with imports ApplicationModuleD , however ApplicationModuleB will receive same instance of service BService but AService will be newly created object since is defined as provider in providers: [AService] import { Module , ModuleInjector } from \"@typeix/modules\" ; import { Injector , Injectable , Inject } from \"@typeix/di\" ; @Injectable class AService { } @Injectable class BService { @Inject () aService : AService ; doWhatever () {} } @Module ({ providers : [ AService , BService ], exports : [ AService , BService ] }) class ApplicationModuleD { @Inject () bService : BService ; @Inject () aService : AService ; } ApplicationModuleC implements ApplicationModuleD and BService, AService are same references exported from ApplicationModuleD. @Module ({ imports : [ ApplicationModuleD ], exports : [ AService , BService ], providers : [] }) class ApplicationModuleC { @Inject () bService : BService ; @Inject () aService : AService ; } ApplicationModuleB implements ApplicationModuleC and BService is same reference however AService is new instance of AService class, because it's provided as new provider on ApplicationModuleB. @Module ({ imports : [ ApplicationModuleC ], providers : [ AService ] }) class ApplicationModuleB { @Inject () bService : BService ; @Inject () aService : AService ; }","title":"Usage"},{"location":"packages/modules/#moduleinjector","text":"NOTE: By default all providers are immutable, however you can define mutable provider keys. If provider is not mutable, and you are trying to create new instance of same provider on current ModuleInjector instance, injector will throw error.","title":"ModuleInjector"},{"location":"packages/modules/#async","text":"Since version 8.x default Injector behavior is converted to async API, if you want to use sync api you need to use ModuleInjector.Sync.createAndResolve difference is that Async API supports Async providers, it's allowed to use of async/await in factory and return Promises in value provider! ModuleInjector.createAndResolve(Class, sharedProviders) special sharedProviders property will create all providers which are provided and visible to all modules, however if module have same provider provided in providers module metadata, new instance will be delivered to that module. class ModuleInjector { static createAndResolve ( Class : Function | IProvider , sharedProviders : Array < Function | IProvider > , mutableKeys? : Array < any > ) : Promise < ModuleInjector > ; get ( Class : Function | IProvider ) : any ; getInjector ( Class : Function | IProvider ) : Injector ; has ( Class : IProvider | Function ) : boolean ; remove ( Class : Function | IProvider ) : boolean ; getAllMetadata () : Map < any , IModuleMetadata > ; createAndResolveSharedProviders ( providers : Array < Function | IProvider > ) : Promise < Injector > ; createAndResolve ( Class : Function | IProvider , mutableKeys? : Array < any > ) : Promise < Injector > ; } Once modules are created by ModuleInjector all objects and references can be accessed via API const injector = await ModuleInjector . createAndResolve ( ApplicationModuleB );","title":"Async"},{"location":"packages/modules/#sync-api","text":"Sync api is accessible via ModuleInjector.Sync.createAndResolve(Class, sharedProviders) or by simply importing SyncModuleInjector class SyncModuleInjector { static createAndResolve ( Class : Function | IProvider , sharedProviders : Array < Function | IProvider > , mutableKeys? : Array < any > ) : SyncModuleInjector ; get ( Class : Function | IProvider ) : any ; getInjector ( Class : Function | IProvider ) : SyncInjector ; has ( Class : IProvider | Function ) : boolean ; remove ( Class : Function | IProvider ) : boolean ; getAllMetadata () : Map < any , IModuleMetadata > ; createAndResolveSharedProviders ( providers : Array < Function | IProvider > ) : SyncInjector ; createAndResolve ( Class : Function | IProvider , mutableKeys? : Array < any > ) : SyncInjector ; } In following example we can see sync api usage: const injector = ModuleInjector . Sync . createAndResolve ( ApplicationModuleB ); const dModule : ApplicationModuleD = injector . get ( ApplicationModuleD ); const cModule : ApplicationModuleC = injector . get ( ApplicationModuleC ); const bModule : ApplicationModuleB = injector . get ( ApplicationModuleB ); bModule . myAction (); const bModuleInjector = injector . getInjector ( ApplicationModuleB ); const bService = bModuleInjector . get ( BService ); bService . doWhatever (); In example above injected service references are evaluated as true const dModuleInjector = injector . getInjector ( ApplicationModuleD ); const cModuleInjector = injector . getInjector ( ApplicationModuleC ); const bModuleInjector = injector . getInjector ( ApplicationModuleB ); bModuleInjector . get ( BService ) === cModuleInjector . get ( BService ) bModuleInjector . get ( BService ) === dModuleInjector . get ( BService ) cModuleInjector . get ( AService ) === dModuleInjector . get ( AService ) bModuleInjector . get ( AService ) != cModuleInjector . get ( AService ) bModuleInjector . get ( AService ) != dModuleInjector . get ( AService )","title":"Sync API"},{"location":"packages/resty/","text":"Resty \u00b6 Fast, unopinionated, minimalist REST framework for building efficient and scalable applications. It uses modern TypeScript and combines elements of OOP, Functional Programming and Reactive Programming. Resty has unique features: Dependency Injection Method Interceptors Modular Application Design Request Interceptors Routing (Dynamic & Static) AWS Lambda Adapter Supports MVC Structure Documentation will be updated and each decorator and interface will be explained in separate section. Usage \u00b6 In example below you can find basic application server starter: import { pipeServer , Controller , Inject , ResolvedRoute , GET , POST , OnError , RootModule , Logger , Router , addRequestInterceptor , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse , createServer } from \"http\" ; // resty supports http, https, http2 @Controller ({ path : \"/\" , interceptors : [], // controller request interceptors executed in order providers : [] // providers created on each request }) class HomeController { @Inject () private request : IncomingMessage ; @Inject () private response : ServerResponse ; @ResolvedRoute () private route : IResolvedRoute ; @GET () actionGet () { return this . route . method . toUpperCase () + \" ACTION\" ; } @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) actionAjax ( body : Buffer ) { return JSON . stringify ( body . toString ()); } // will match all routes on this controller @OnError ( \"*\" ) errorCase () { return \"FIRE ERROR CASE\" ; } @GET ( \"redirect\" ) actionRedirect () { this . response . setHeader ( \"Location\" , \"/mypage\" ); this . response . writeHead ( 307 ); this . response . end (); } } // DEFINE MODULE @RootModule ({ imports : [], // import other modules, created at application bootstrap shared_providers : [ { provide : Logger , useFactory : () => new Logger ({ options : { level : \"debug\" }}) }, Router ], providers : [], // providers created at application bootstrap controllers : [ HomeController ] // define controllers }) class ApplicationModule {} // START SERVER const server = createServer (); pipeServer ( server , ApplicationModule ); server . listen ( 4000 );","title":"@typeix/resty"},{"location":"packages/resty/#resty","text":"Fast, unopinionated, minimalist REST framework for building efficient and scalable applications. It uses modern TypeScript and combines elements of OOP, Functional Programming and Reactive Programming. Resty has unique features: Dependency Injection Method Interceptors Modular Application Design Request Interceptors Routing (Dynamic & Static) AWS Lambda Adapter Supports MVC Structure Documentation will be updated and each decorator and interface will be explained in separate section.","title":"Resty"},{"location":"packages/resty/#usage","text":"In example below you can find basic application server starter: import { pipeServer , Controller , Inject , ResolvedRoute , GET , POST , OnError , RootModule , Logger , Router , addRequestInterceptor , BodyAsBufferInterceptor } from \"@typeix/resty\" ; import { IncomingMessage , ServerResponse , createServer } from \"http\" ; // resty supports http, https, http2 @Controller ({ path : \"/\" , interceptors : [], // controller request interceptors executed in order providers : [] // providers created on each request }) class HomeController { @Inject () private request : IncomingMessage ; @Inject () private response : ServerResponse ; @ResolvedRoute () private route : IResolvedRoute ; @GET () actionGet () { return this . route . method . toUpperCase () + \" ACTION\" ; } @POST () @addRequestInterceptor ( BodyAsBufferInterceptor ) actionAjax ( body : Buffer ) { return JSON . stringify ( body . toString ()); } // will match all routes on this controller @OnError ( \"*\" ) errorCase () { return \"FIRE ERROR CASE\" ; } @GET ( \"redirect\" ) actionRedirect () { this . response . setHeader ( \"Location\" , \"/mypage\" ); this . response . writeHead ( 307 ); this . response . end (); } } // DEFINE MODULE @RootModule ({ imports : [], // import other modules, created at application bootstrap shared_providers : [ { provide : Logger , useFactory : () => new Logger ({ options : { level : \"debug\" }}) }, Router ], providers : [], // providers created at application bootstrap controllers : [ HomeController ] // define controllers }) class ApplicationModule {} // START SERVER const server = createServer (); pipeServer ( server , ApplicationModule ); server . listen ( 4000 );","title":"Usage"},{"location":"packages/router/","text":"Router \u00b6 Typeix Router is very fast lightweight wrapper around Node.js http, https, http2 servers, which supports dynamic routing, regex name capturing in route definitions, error handling on each route (global, local error handlers). Installing: npm i @typeix/di @typeix/router --save npm i @types/node --save-dev Resolved or matched route will be delivered in route handler interface IResolvedRoute { params : { [ key : string ] : string }; headers : { [ key : string ] : any }; url : URI ; path : string ; method : string ; } Router API: class Router { static parseURI ( path : string , headers : { [ key : string ] : any ; }, defaultHost? : string ) : URI ; addRules ( rules : Array < IRouteConfig > ) : void ; addRule ( Class : TRoute , config? : IRouteConfig ) : void ; pipe ( server : Server ) : Server ; get ( path : string , handler : IRouteHandler ) : this ; head ( path : string , handler : IRouteHandler ) : this ; post ( path : string , handler : IRouteHandler ) : this ; put ( path : string , handler : IRouteHandler ) : this ; delete ( path : string , handler : IRouteHandler ) : this ; connect ( path : string , handler : IRouteHandler ) : this ; options ( path : string , handler : IRouteHandler ) : this ; trace ( path : string , handler : IRouteHandler ) : this ; patch ( path : string , handler : IRouteHandler ) : this ; onError ( path : string , handler : IRouteHandler ) : this ; } Defining Routes \u00b6 Creating routes can be done via REST method api or via addRules, dynamic router can be implemented via addRule but requires implementation of custom RouteRule. import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . post ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => { return { id : route.params.id , name : \"Igor\" } }); router . patch ( \"/api/users/<id:(\\\\d+)>\" , async ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); return { id : route.params.id , name : \"Igor\" } }); router . get ( \"/favicon.ico\" , ( injector : Injector , route : IResolvedRoute ) => { const response = injector . get ( ServerResponse ); response . end ( readFileSync ( \"./public/favicon.ico\" )); }); Error Handling \u00b6 If any errors is thrown in route handler, router will forward exception to internal route handler. import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . post ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . patch ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . onError ( \"/api/(.*)\" , ( injector : Injector , route : IResolvedRoute ) => { return {... route , handler : \"[Function handler]\" , statusCode : response.statusCode }; }); router . onError ( \"(.*)\" , ( injector : Injector , route : IResolvedRoute ) => { return \"GLOBAL HANDLER\" ; }); const server = router . pipe ( createServer ()); server . listen ( 4000 ); Supported Servers \u00b6 Router supports all implemented servers in Node.js however http2 is implemented via http2 compatibility API `Http2ServerRequest, Http2ServerResponse HTTP \u00b6 import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); const response = injector . get ( ServerResponse ); }); const server = router . pipe ( createServer ()); server . listen ( 4000 ); HTTPS \u00b6 import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"https\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); const response = injector . get ( ServerResponse ); }); const options = { key : readFileSync ( 'localhost-privkey.pem' ), cert : readFileSync ( 'localhost-cert.pem' ) }; const server = router . pipe ( createServer ( options )); server . listen ( 4000 ); HTTP2 \u00b6 import { Router , Injector } from \"@typeix/router\" ; import { createServer , Http2ServerRequest , Http2ServerResponse } from \"http2\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( Http2ServerRequest ); const response = injector . get ( Http2ServerResponse ); }); const options = { key : readFileSync ( 'localhost-privkey.pem' ), cert : readFileSync ( 'localhost-cert.pem' ) }; const server = router . pipe ( createServer ( options )); server . listen ( 4000 );","title":"@typeix/router"},{"location":"packages/router/#router","text":"Typeix Router is very fast lightweight wrapper around Node.js http, https, http2 servers, which supports dynamic routing, regex name capturing in route definitions, error handling on each route (global, local error handlers). Installing: npm i @typeix/di @typeix/router --save npm i @types/node --save-dev Resolved or matched route will be delivered in route handler interface IResolvedRoute { params : { [ key : string ] : string }; headers : { [ key : string ] : any }; url : URI ; path : string ; method : string ; } Router API: class Router { static parseURI ( path : string , headers : { [ key : string ] : any ; }, defaultHost? : string ) : URI ; addRules ( rules : Array < IRouteConfig > ) : void ; addRule ( Class : TRoute , config? : IRouteConfig ) : void ; pipe ( server : Server ) : Server ; get ( path : string , handler : IRouteHandler ) : this ; head ( path : string , handler : IRouteHandler ) : this ; post ( path : string , handler : IRouteHandler ) : this ; put ( path : string , handler : IRouteHandler ) : this ; delete ( path : string , handler : IRouteHandler ) : this ; connect ( path : string , handler : IRouteHandler ) : this ; options ( path : string , handler : IRouteHandler ) : this ; trace ( path : string , handler : IRouteHandler ) : this ; patch ( path : string , handler : IRouteHandler ) : this ; onError ( path : string , handler : IRouteHandler ) : this ; }","title":"Router"},{"location":"packages/router/#defining-routes","text":"Creating routes can be done via REST method api or via addRules, dynamic router can be implemented via addRule but requires implementation of custom RouteRule. import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . post ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => { return { id : route.params.id , name : \"Igor\" } }); router . patch ( \"/api/users/<id:(\\\\d+)>\" , async ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); return { id : route.params.id , name : \"Igor\" } }); router . get ( \"/favicon.ico\" , ( injector : Injector , route : IResolvedRoute ) => { const response = injector . get ( ServerResponse ); response . end ( readFileSync ( \"./public/favicon.ico\" )); });","title":"Defining Routes"},{"location":"packages/router/#error-handling","text":"If any errors is thrown in route handler, router will forward exception to internal route handler. import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . post ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . get ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . patch ( \"/api/users/<id:(\\\\d+)>\" , ( injector : Injector , route : IResolvedRoute ) => {}); router . onError ( \"/api/(.*)\" , ( injector : Injector , route : IResolvedRoute ) => { return {... route , handler : \"[Function handler]\" , statusCode : response.statusCode }; }); router . onError ( \"(.*)\" , ( injector : Injector , route : IResolvedRoute ) => { return \"GLOBAL HANDLER\" ; }); const server = router . pipe ( createServer ()); server . listen ( 4000 );","title":"Error Handling"},{"location":"packages/router/#supported-servers","text":"Router supports all implemented servers in Node.js however http2 is implemented via http2 compatibility API `Http2ServerRequest, Http2ServerResponse","title":"Supported Servers"},{"location":"packages/router/#http","text":"import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"http\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); const response = injector . get ( ServerResponse ); }); const server = router . pipe ( createServer ()); server . listen ( 4000 );","title":"HTTP"},{"location":"packages/router/#https","text":"import { Router , Injector } from \"@typeix/router\" ; import { createServer , IncomingMessage , ServerResponse } from \"https\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( IncomingMessage ); const response = injector . get ( ServerResponse ); }); const options = { key : readFileSync ( 'localhost-privkey.pem' ), cert : readFileSync ( 'localhost-cert.pem' ) }; const server = router . pipe ( createServer ( options )); server . listen ( 4000 );","title":"HTTPS"},{"location":"packages/router/#http2","text":"import { Router , Injector } from \"@typeix/router\" ; import { createServer , Http2ServerRequest , Http2ServerResponse } from \"http2\" ; import { readFileSync } from \"fs\" ; const router : Router = Injector . createAndResolve ( Router , []). get ( Router ); router . get ( \"/\" , ( injector : Injector , route : IResolvedRoute ) => { const request = injector . get ( Http2ServerRequest ); const response = injector . get ( Http2ServerResponse ); }); const options = { key : readFileSync ( 'localhost-privkey.pem' ), cert : readFileSync ( 'localhost-cert.pem' ) }; const server = router . pipe ( createServer ( options )); server . listen ( 4000 );","title":"HTTP2"},{"location":"packages/resty/aws-lambda-integration/","text":"Resty \u00b6 Using lambda adapter you can simply transform your application to simply run as AWS lambda server. You can deploy your build with terraform on top of lambda you should run api gateway as proxy which forwards requests to lambda, make sure that you assigned correct permissions. I will add complete code example and schematics starter! Azure and GCP adapters will be added as well! Usage \u00b6 In example below you can find basic application server starter: // DEFINE MODULE @RootModule ({ imports : [], // import other modules, created at application bootstrap shared_providers : [ { provide : Logger , useFactory : () => new Logger ({ options : { level : \"debug\" }}) }, Router ], providers : [], // providers created at application bootstrap controllers : [ HomeController ] // define controllers }) class ApplicationModule {} // START SERVER export handler = lambdaServer ( ApplicationModule , {});","title":"@typeix/resty-aws-lambda"},{"location":"packages/resty/aws-lambda-integration/#resty","text":"Using lambda adapter you can simply transform your application to simply run as AWS lambda server. You can deploy your build with terraform on top of lambda you should run api gateway as proxy which forwards requests to lambda, make sure that you assigned correct permissions. I will add complete code example and schematics starter! Azure and GCP adapters will be added as well!","title":"Resty"},{"location":"packages/resty/aws-lambda-integration/#usage","text":"In example below you can find basic application server starter: // DEFINE MODULE @RootModule ({ imports : [], // import other modules, created at application bootstrap shared_providers : [ { provide : Logger , useFactory : () => new Logger ({ options : { level : \"debug\" }}) }, Router ], providers : [], // providers created at application bootstrap controllers : [ HomeController ] // define controllers }) class ApplicationModule {} // START SERVER export handler = lambdaServer ( ApplicationModule , {});","title":"Usage"}]}